ASP.NET Core MVC 概觀 
(https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc?view=aspnetcore-5.0&tabs=visual-studio)
  > 什麼是MVC模式?
    1. M = Model(模型), V = View(檢視), C = Controller(控制器).
    2. 關注點分離(SOC)是拆分為MVC的優點之一.
    3. View & Controller都相依於Model, 
        但Model不相依於View or Controller, 這是分離的主要優點之一.

    > Model職責
      1. 保存應用程式狀態, 商務邏輯或作業.
      2. 商務邏輯應與保存應用程式狀態的實作邏輯, 一起封裝在模型中.
      3. 強型別檢視 常會使用 {ViewModel類型}, 目於在於包含要在檢視上顯示的資料.
      4. Controller 會從 Model 建立, 並填入這些 ViewModel類型 執行個體.
      
    > View職責
      1. 檢視會負責透過使用者介面展示內容。
      2. 它們使用 Razor view engine將 .net 程式碼內嵌在 HTML 標籤中。 
      3. 檢視內應該有基本邏輯，而且 {其中的任何邏輯都應該與展示內容相關}。 
      4. 如果您需要在檢視檔案中執行大量邏輯以便顯示複雜模型中的資料，
          請考慮使用 {檢視元件、ViewModel 或檢視範本} 來簡化檢視。

    > Controller職責
      1. 控制器是處理使用者互動、使用模型，並在最終選取要呈現之檢視的元件。 
      2. 在 MVC 應用程式中，檢視只會顯示資訊，而控制器則會處理及回應使用者輸入和互動。 
      3. 在 MVC 模式中，控制器是初始進入點，負責選取要使用的模型類型及要呈現的檢視 
          (如其名稱所指，它會控制應用程式回應指定要求的方式)。
      
      !! Notice !!: Controller不應該太過複雜, 如有太多商務邏輯請移至 {領域模型} 中.
      !! Notice !!: Controller經常執行相同動作類型時, 請將常用動作移至 {篩選} 中.
    
  > 什麼是 ASP.NET Core MVC
    1. 它是一個架構, 輕量型, 開放原始碼及可高度測試的架構.
    2. 可建立動態網站, 套用SOC. 可掌握HTML標記, 適合TDD開發, 並使用最新網站標準.

  > 功能
    > 路由
      1. 以 {慣例為基礎的路由}, 可定義全域AP能接受的URL格式, 及這些URL格式如何對應至指定控制器的特定動作方法.
        routes.MapRoute(name: "Default", template: "{controller=Home}/{action=Index}/{id?}");
      2. {屬性路由}, 指定路由屬性, 來裝飾這些控制器及動作方法.
        [Route("api/[controller]")]
        public class ProductsController : Controller
        {
            [HttpGet("{id}")]
            public IActionResult GetProduct(int id)
            {
              ...
            }
        }
    
    > 模型繫結
      1. 自動將用戶端REQUEST資料, 轉換為Controller可處理的物件.
      2. Controller不必管資料內容, 它只會將資料當作動作方式的參數.

        public async Task<IActionResult> Login(LoginViewModel model, string returnUrl = null) { ... }

        // https://localhost:5001/Helloworld/welcome?name=KL&numTimes=25
        // 控制器會自動對應 "網址參數(?後面的值)".
        public string Welcome(string name = "Jack", int numTimes = 1)

        // https://localhost:5001/helloworld/welcome/50?name=Leo&age=25
        // 控制器也會自動對應 "Routing URL", 
        // 參考路由定義, routes.MapRoute(name: "Default", template: "{controller=Home}/{action=Index}/{id?}");
        // id?, 有個?表示它是選項欄位.
        public string Welcome(string name = "Judy", int ID = 1, int age = 28)

    > 模型驗證
      1. 指定資料註解{驗證屬性}, 來裝飾這些模型物件.
      2. 用戶端先檢查, 伺服器端再檢查, 最後再呼叫控制器動作.

        // 指定資料註解{驗證屬性}, 來裝飾這些模型物件.
        using System.ComponentModel.DataAnnotations;
        public class LoginViewModel
        {
            [Required]
            [EmailAddress]
            public string Email { get; set; }

            [Required]
            [DataType(DataType.Password)]
            public string Password { get; set; }

            [Display(Name = "Remember me?")]
            public bool RememberMe { get; set; }
        }

        // 控制器動作
        public async Task<IActionResult> Login(LoginViewModel model, string returnUrl = null)
        {
            if (ModelState.IsValid)
            {
              // work with the model
            }
            // At this point, something failed, redisplay form
            return View(model);
        }

    > 相依性插入
      1. 方式1: 在控制器中, 利用建構函式要求所需的服務.
      2. 方式2: 在檢視中, 利用 @inject 指示詞 使用所需的服務.

        @inject SomeService ServiceName

        <!DOCTYPE html>
        <html lang="en">
        <head>
            <title>@ServiceName.GetTitle</title>
        </head>
        <body>
            <h1>@ServiceName.GetTitle</h1>
        </body>
        </html>

    > 篩選器
      1. 時機: 常用於{例外狀況處理}或{授權}.
      2. 功能: 篩選可執行動作方法的自訂處理前後邏輯，並可設定為在指定要求之執行管線內的特定時間點執行。
      3. 套用: 把篩選作為屬性套用於控制器、動作或全域執行.

        [Authorize]
        public class AccountController : Controller

    > 區域
      1. 時機: 大型電子商務應用程式, 可區分為多個BU, 例: 結帳、帳單、商品查詢等不同功能別.
      2. 功能: 將程式拆解為 個別自行運作的單元模組, 每個單元模組擁有各自的MVC架構.

    > Web API
      1. ASP.NET Core MVC 支援Web API.
      2. 支援 格式化資料 JSON OR XML.
      3. 支援 跨原始來源資源共用 (CORS).

    > 可測試性
      1. ASP.NET Core MVC 使用 相依性插入(DI)概念, 服務適合於單元測試.
      2. 例: 利用Entiry Framework 的 TestHost & InMemory, 進入整合測試.
    
    > Razor 查看引擎
      1. 簡單來說, 就是View裡面使用 內嵌C#程式碼, 再由Razor動態產生前端HTML內容.

        <ul>
            @for (int i = 0; i < 5; i++) {
                <li>List item @i</li>
            }
        </ul>

    > 強型別檢視(View)
      0. 檢視內不應該 (1)執行商業邏輯, (2)與資料庫直接互動.
      0. 檢視內應該 (3)只使用控制器提供的資料, 以維持 Clean & Testable & Maintainable.
      1. Razor MVC 中的 views 可以根據您的模型以強型別為基礎。
      2. 控制器(Controller)可以將強型別模型(ViewModel)傳遞至檢視.
      2. !! (註: 首選作法, 使用 ViewModel傳資料給View, 而非使用 ViewData 集合來傳)
      3. 控制器(Controller)內的動作方法, 等同於檢視(View)檔案名稱.

        @model IEnumerable<Product>
        <ul>
            @foreach (Product p in Model)
            {
                <li>@p.Name</li>
            }
        </ul>

        // 例:return View(); 結果會傳給 Index.cshtml 檢視檔案作處理.
        public class HelloWorldController: Controller
        {
            public IActionResult Index()
            {
              return View();
            }
        }

    > HTML標籤協助程式
      1. 自訂HTML標籤內屬性(例:<environment>), 或變更現有HTML標籤行為(例:<label>)
      
        <!--例1: EnvironmentTagHelper 可根據執行階段環境 (例如開發、預備或生產)，將不同的指令碼加入檢視-->
        <environment names="Development">
            <script src="~/lib/jquery/dist/jquery.js"></script>
        </environment>
        <environment names="Staging,Production">
            <script src="https://ajax.aspnetcdn.com/ajax/jquery/jquery-2.1.4.min.js"
                    asp-fallback-src="~/lib/jquery/dist/jquery.min.js"
                    asp-fallback-test="window.jQuery">
            </script>
        </environment>
        
        <!--例2: 變更現有HTML標籤行為, 點選下方的LINK, 它會導向 Account Controller 內的 Login Action -->
        <p>
            Thank you for confirming your email.
            Please <a asp-controller="Account" asp-action="Login">Click here to Log in</a>.
        </p>

    > 檢視元件
      1. 類似自訂控制項/部分檢視, 可在整個AP中重複使用.
      2. 將可共用的邏輯加以封裝

    > 區分環境別 by Startup.cs (for ASP.NET CORE MVC 架構)
        public Startup(IConfiguration configuration, IWebHostEnvironment env)
        {
            Configuration = configuration;
            _env = env;
        }
        public IConfiguration Configuration {get;}
        private readonly IWebHostEnvironment _env;
        public void ConfigureServices(IServiceCollection services)
        {
            if (_env.IsDevelopment())
            {
                Console.WriteLine(_env.EnvironmentName);
            }
            else if (_env.IsStaging())
            {
                Console.WriteLine(_env.EnvironmentName);
            }
            else
            {
                Console.WriteLine("Not dev or staging env.");
            }
            
            services.AddControllersWithViews();
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app)
        {
            if (_env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler("/Home/Error");
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }
            app.UseHttpsRedirection();
            app.UseStaticFiles();

            app.UseRouting();

            app.UseAuthorization();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllerRoute(
                    name: "default",
                    pattern: "{controller=Home}/{action=Index}/{id?}");
            });
        }

  > 安裝ORM套件(EntityFrameworkCore)
      dotnet tool install --global dotnet-ef
      dotnet tool install --global dotnet-aspnet-codegenerator
      dotnet add package Microsoft.EntityFrameworkCore.Design
      dotnet add package Microsoft.EntityFrameworkCore.SQLite
      dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
      dotnet add package Microsoft.EntityFrameworkCore.SqlServer

  > 新增MODEL後, 產生對應的Controller & View (ORM套件要先裝, 不然程式碼生不出來)
      dotnet-aspnet-codegenerator controller 
      -name JobsController 
      -m Jobs 
      -dc JobsContext 
      --relativeFolderPath Controllers 
      --useDefaultLayout 
      --referenceScriptLibraries
  
  > 測試用SQLite, 上線用SqlServer by Startup.cs

  > 接下來, 資料庫初始移轉(inital migration), 依據 JobsContext 所產生.

      dotnet ef migrations add InitialCreate
      dotnet ef database update
      dotnet ef database update -- --environment Development
      dotnet ef database update -- --environment Production

      問題:
        執行 "dotnet ef database update"後, 出現下列錯誤. 
        Connection string keyword 'server' is not supported. For a possible alternative, see https://go.microsoft.com/fwlink/?linkid=2142181.

      原因: 
        1. EF自動產生的是SQL Server用連接字串,不支援SQLite[測試環境我把它設為讀取SQLite,正式環境讀取SQL Server],所以會
        2. {C:\Users\syscc\Documents\Visual Studio Code\Projects\MvcMovie\appsettings.json}
        3. "JobsContext": "Server=(localdb)\\mssqllocaldb;Database=JobsContext-0d04fe32-b4eb-47cb-a886-0161e3b643af;Trusted_Connection=True;MultipleActiveResultSets=true"

      解決辦法: 
        1. 新增SQLite用連接字串. @appsettings.json => 
            "JobsContext-Dev": "Data Source=MvcJob.db"
        2. 測試環境讀取SQLite用連接字串字串即可. @Startup.cs => 
            public void ConfigureServices(IServiceCollection services)
            {
                services.AddControllersWithViews();
                services.AddDbContext<JobsContext>(options =>
                {
                    var connectionString = Configuration.GetConnectionString("JobsContext");
                    if (Environment.IsDevelopment() || Environment.IsStaging())
                    {
                        Console.WriteLine(Environment.EnvironmentName);
                        Console.WriteLine("Now is IsDevelopment or IsStaging");
                        connectionString = Configuration.GetConnectionString("JobsContext-Dev"); //重點在這裡.
                        options.UseSqlite(connectionString);
                    }
                    else
                    {
                        Console.WriteLine("Not dev or staging env.");
                        options.UseSqlServer(connectionString);
                    }
                });            
            }

  > 相容性版本
      1. {SetCompatibilityVersion} 方法可讓應用程式加入或退出 ASP.NET Core MVC 2.1 或更新版本所引入的可能重大行為變更。

  > 其他資源


ASP.NET Core MVC with EF Core (加強資料庫工具應用.) - tutorial series
https://docs.microsoft.com/en-us/aspnet/core/data/ef-mvc/?view=aspnetcore-5.0