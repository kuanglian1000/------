={進行中}=

Get started with ASP.NET Core MVC (MVC架構完整RUN一次) => ProjectName: MvcMovie
https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc?view=aspnetcore-5.0&tabs=visual-studio

  Part 2, add a controller to an ASP.NET Core MVC app
  Part 3, add a view to an ASP.NET Core MVC app
  Part 4, add a model to an ASP.NET Core MVC app
  Part 5, work with a database in an ASP.NET Core MVC app
  Part 6, controller methods and views in ASP.NET Core
  Part 7, add search to an ASP.NET Core MVC app
  Part 8, add a new field to an ASP.NET Core MVC app
  Part 9, add validation to an ASP.NET Core MVC app
  Part 10, examine the Details and Delete methods of an ASP.NET Core app

ASP.NET Core MVC(檢視)
https://docs.microsoft.com/en-us/aspnet/core/mvc/views/overview?view=aspnetcore-5.0

ASP.NET Core MVC(部分檢視, 先跳過)
https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-5.0

ASP.NET Core MVC(控制器)
https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/actions?view=aspnetcore-5.0

ASP.NET Core MVC(路由)
https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/routing?view=aspnetcore-5.0

ASP.NET Core MVC(控制器插入服務. Dependency injection into controllers in ASP.NET Core)
https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/dependency-injection?view=aspnetcore-5.0

ASP.NET Core MVC(檢視插入服務. Dependency injection into views in ASP.NET Core)
https://docs.microsoft.com/en-us/aspnet/core/mvc/views/dependency-injection?view=aspnetcore-5.0

ASP.NET Core MVC(單元測試. Unit test controller logic in ASP.NET Core)
https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/testing?view=aspnetcore-5.0

Upload files in ASP.NET Core (for 訪視照片檔案上傳用)
https://docs.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads?view=aspnetcore-5.0

Host ASP.NET Core on Windows with IIS (for 佈署上線)
https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/?view=aspnetcore-5.0

={完成}=

ASP.NET Core MVC 概觀 (MVC > Overview) (2021/07/08)
https://docs.microsoft.com/en-us/aspnet/core/mvc/overview?view=aspnetcore-5.0
  > 什麼是MVC模式?
    1. M = Model(模型), V = View(檢視), C = Controller(控制器).
    2. 關注點分離(SOC)是拆分為MVC的優點之一.
    3. View & Controller都相依於Model, 
        但Model不相依於View or Controller, 這是分離的主要優點之一.

    > Model職責
      1. 保存應用程式狀態, 商務邏輯或作業.
      2. 商務邏輯應與保存應用程式狀態的實作邏輯, 一起封裝在模型中.
      3. 強型別檢視 常會使用 {ViewModel類型}, 目於在於包含要在檢視上顯示的資料.
      4. Controller 會從 Model 建立, 並填入這些 ViewModel類型 執行個體.
      
    > View職責
      1. 檢視會負責透過使用者介面展示內容。
      2. 它們使用 Razor view engine將 .net 程式碼內嵌在 HTML 標籤中。 
      3. 檢視內應該有基本邏輯，而且 {其中的任何邏輯都應該與展示內容相關}。 
      4. 如果您需要在檢視檔案中執行大量邏輯以便顯示複雜模型中的資料，
          請考慮使用 {檢視元件、ViewModel 或檢視範本} 來簡化檢視。

    > Controller職責
      1. 控制器是處理使用者互動、使用模型，並在最終選取要呈現之檢視的元件。 
      2. 在 MVC 應用程式中，檢視只會顯示資訊，而控制器則會處理及回應使用者輸入和互動。 
      3. 在 MVC 模式中，控制器是初始進入點，負責選取要使用的模型類型及要呈現的檢視 
          (如其名稱所指，它會控制應用程式回應指定要求的方式)。
      
      !! Notice !!: Controller不應該太過複雜, 如有太多商務邏輯請移至 {領域模型} 中.
      !! Notice !!: Controller經常執行相同動作類型時, 請將常用動作移至 {篩選} 中.
    
  > 什麼是 ASP.NET Core MVC
    1. 它是一個架構, 輕量型, 開放原始碼及可高度測試的架構.
    2. 可建立動態網站, 套用SOC. 可掌握HTML標記, 適合TDD開發, 並使用最新網站標準.

  > 功能
    > 路由
      1. 以 {慣例為基礎的路由}, 可定義全域AP能接受的URL格式, 及這些URL格式如何對應至指定控制器的特定動作方法.
        routes.MapRoute(name: "Default", template: "{controller=Home}/{action=Index}/{id?}");
      2. {屬性路由}, 指定路由屬性, 來裝飾這些控制器及動作方法.
        [Route("api/[controller]")]
        public class ProductsController : Controller
        {
            [HttpGet("{id}")]
            public IActionResult GetProduct(int id)
            {
              ...
            }
        }
    
    > 模型繫結
      1. 自動將用戶端REQUEST資料, 轉換為Controller可處理的物件.
      2. Controller不必管資料內容, 它只會將資料當作動作方式的參數.

        public async Task<IActionResult> Login(LoginViewModel model, string returnUrl = null) { ... }

        // https://localhost:5001/Helloworld/welcome?name=KL&numTimes=25
        // 控制器會自動對應 "網址參數(?後面的值)".
        public string Welcome(string name = "Jack", int numTimes = 1)

        // https://localhost:5001/helloworld/welcome/50?name=Leo&age=25
        // 控制器也會自動對應 "Routing URL", 
        // 參考路由定義, routes.MapRoute(name: "Default", template: "{controller=Home}/{action=Index}/{id?}");
        // id?, 有個?表示它是選項欄位.
        public string Welcome(string name = "Judy", int ID = 1, int age = 28)

    > 模型驗證
      1. 指定資料註解{驗證屬性}, 來裝飾這些模型物件.
      2. 用戶端先檢查, 伺服器端再檢查, 最後再呼叫控制器動作.

        // 指定資料註解{驗證屬性}, 來裝飾這些模型物件.
        using System.ComponentModel.DataAnnotations;
        public class LoginViewModel
        {
            [Required]
            [EmailAddress]
            public string Email { get; set; }

            [Required]
            [DataType(DataType.Password)]
            public string Password { get; set; }

            [Display(Name = "Remember me?")]
            public bool RememberMe { get; set; }
        }

        // 控制器動作
        public async Task<IActionResult> Login(LoginViewModel model, string returnUrl = null)
        {
            if (ModelState.IsValid)
            {
              // work with the model
            }
            // At this point, something failed, redisplay form
            return View(model);
        }

    > 相依性插入
      1. 方式1: 在控制器中, 利用建構函式要求所需的服務.
      2. 方式2: 在檢視中, 利用 @inject 指示詞 使用所需的服務.

        @inject SomeService ServiceName

        <!DOCTYPE html>
        <html lang="en">
        <head>
            <title>@ServiceName.GetTitle</title>
        </head>
        <body>
            <h1>@ServiceName.GetTitle</h1>
        </body>
        </html>

    > 篩選器
      1. 時機: 常用於{例外狀況處理}或{授權}.
      2. 功能: 篩選可執行動作方法的自訂處理前後邏輯，並可設定為在指定要求之執行管線內的特定時間點執行。
      3. 套用: 把篩選作為屬性套用於控制器、動作或全域執行.

        [Authorize]
        public class AccountController : Controller

    > 區域
      1. 時機: 大型電子商務應用程式, 可區分為多個BU, 例: 結帳、帳單、商品查詢等不同功能別.
      2. 功能: 將程式拆解為 個別自行運作的單元模組, 每個單元模組擁有各自的MVC架構.

    > Web API
      1. ASP.NET Core MVC 支援Web API.
      2. 支援 格式化資料 JSON OR XML.
      3. 支援 跨原始來源資源共用 (CORS).

    > 可測試性
      1. ASP.NET Core MVC 使用 相依性插入(DI)概念, 服務適合於單元測試.
      2. 例: 利用Entiry Framework 的 TestHost & InMemory, 進入整合測試.
    
    > Razor 查看引擎
      1. 簡單來說, 就是View裡面使用 內嵌C#程式碼, 再由Razor動態產生前端HTML內容.

        <ul>
            @for (int i = 0; i < 5; i++) {
                <li>List item @i</li>
            }
        </ul>

    > 強型別檢視(View)
      0. 檢視內不應該 (1)執行商業邏輯, (2)與資料庫直接互動.
      0. 檢視內應該 (3)只使用控制器提供的資料, 以維持 Clean & Testable & Maintainable.
      1. Razor MVC 中的 views 可以根據您的模型以強型別為基礎。
      2. 控制器(Controller)可以將強型別模型(ViewModel)傳遞至檢視.
      2. !! (註: 首選作法, 使用 ViewModel傳資料給View, 而非使用 ViewData 集合來傳)
      3. 控制器(Controller)內的動作方法, 等同於檢視(View)檔案名稱.

        @model IEnumerable<Product>
        <ul>
            @foreach (Product p in Model)
            {
                <li>@p.Name</li>
            }
        </ul>

        // 例:return View(); 結果會傳給 Index.cshtml 檢視檔案作處理.
        public class HelloWorldController: Controller
        {
            public IActionResult Index()
            {
              return View();
            }
        }

    > HTML標籤協助程式
      1. 自訂HTML標籤內屬性(例:<environment>), 或變更現有HTML標籤行為(例:<label>)
      
        <!--例1: EnvironmentTagHelper 可根據執行階段環境 (例如開發、預備或生產)，將不同的指令碼加入檢視-->
        <environment names="Development">
            <script src="~/lib/jquery/dist/jquery.js"></script>
        </environment>
        <environment names="Staging,Production">
            <script src="https://ajax.aspnetcdn.com/ajax/jquery/jquery-2.1.4.min.js"
                    asp-fallback-src="~/lib/jquery/dist/jquery.min.js"
                    asp-fallback-test="window.jQuery">
            </script>
        </environment>
        
        <!--例2: 變更現有HTML標籤行為, 點選下方的LINK, 它會導向 Account Controller 內的 Login Action -->
        <p>
            Thank you for confirming your email.
            Please <a asp-controller="Account" asp-action="Login">Click here to Log in</a>.
        </p>

    > 檢視元件
      1. 類似自訂控制項/部分檢視, 可在整個AP中重複使用.
      2. 將可共用的邏輯加以封裝

    > 區分環境別 by Startup.cs (for ASP.NET CORE MVC 架構)
      * 完整範例程式
        public Startup(IConfiguration configuration, IWebHostEnvironment env)
        {
            Environment = env;
            Configuration = configuration;
        }
        public IConfiguration Configuration {get;}
        private IWebHostEnvironment Environment {get;}
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllersWithViews();
            services.AddDbContext<JobsContext>(options =>
            {
                var connectionString = Configuration.GetConnectionString("JobsContext");
                if (Environment.IsDevelopment() || Environment.IsStaging())
                {
                    Console.WriteLine(Environment.EnvironmentName);
                    Console.WriteLine("Now is IsDevelopment or IsStaging");
                    //connectionString = Configuration.GetConnectionString("JobsContext-Dev"); //重點在這裡.
                    options.UseSqlite(connectionString);
                }
                else
                {
                    Console.WriteLine("Not dev or staging env.");
                    options.UseSqlServer(connectionString);
                }
            });            
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app)
        {
            if (Environment.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler("/Home/Error");
                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
                app.UseHsts();
            }
            app.UseHttpsRedirection();
            app.UseStaticFiles();

            app.UseRouting();

            app.UseAuthorization();

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllerRoute(
                    name: "default",
                    pattern: "{controller=Home}/{action=Index}/{id?}");
            });
        }
    
  > 安裝ORM套件(EntityFrameworkCore)
      dotnet tool install --global dotnet-ef
      dotnet tool install --global dotnet-aspnet-codegenerator
      dotnet add package Microsoft.EntityFrameworkCore.Design
      dotnet add package Microsoft.EntityFrameworkCore.SQLite
      dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
      dotnet add package Microsoft.EntityFrameworkCore.SqlServer

  > {新增Model後}, 產生對應的Controller & View (ORM套件要先裝, 不然程式碼生不出來)
      dotnet-aspnet-codegenerator controller 
      -name JobsController 
      -m Jobs 
      -dc JobsContext 
      --relativeFolderPath Controllers 
      --useDefaultLayout 
      --referenceScriptLibraries
  
  > 測試用SQLite, 上線用SqlServer by Startup.cs

  > 接下來, 資料庫初始移轉(inital migration), 依據 JobsContext 所產生.

      dotnet ef migrations add InitialCreate
      dotnet ef database update
      dotnet ef database update -- --environment Development
      dotnet ef database update -- --environment Production

      問題:
        執行 "dotnet ef database update"後, 出現下列錯誤. 
        Connection string keyword 'server' is not supported. For a possible alternative, see https://go.microsoft.com/fwlink/?linkid=2142181.

      原因: 
        1. EF自動產生的是SQL Server用連接字串,不支援SQLite[測試環境我把它設為讀取SQLite,正式環境讀取SQL Server],所以會
        2. {C:\Users\syscc\Documents\Visual Studio Code\Projects\MvcMovie\appsettings.json}
        3. "JobsContext": "Server=(localdb)\\mssqllocaldb;Database=JobsContext-0d04fe32-b4eb-47cb-a886-0161e3b643af;Trusted_Connection=True;MultipleActiveResultSets=true"

      解決辦法: 
        1. 新增SQLite用連接字串. @appsettings.json => 
            "JobsContext-Dev": "Data Source=MvcJob.db"
        2. 測試環境讀取SQLite用連接字串字串即可. @Startup.cs => 
            public void ConfigureServices(IServiceCollection services)
            {
                services.AddControllersWithViews();
                services.AddDbContext<JobsContext>(options =>
                {
                    var connectionString = Configuration.GetConnectionString("JobsContext");
                    if (Environment.IsDevelopment() || Environment.IsStaging())
                    {
                        Console.WriteLine(Environment.EnvironmentName);
                        Console.WriteLine("Now is IsDevelopment or IsStaging");
                        connectionString = Configuration.GetConnectionString("JobsContext-Dev"); //重點在這裡.
                        options.UseSqlite(connectionString);
                    }
                    else
                    {
                        Console.WriteLine("Not dev or staging env.");
                        options.UseSqlServer(connectionString);
                    }
                });            
            }

  > 相容性版本
      1. {SetCompatibilityVersion} 方法可讓應用程式加入或退出 ASP.NET Core MVC 2.1 或更新版本所引入的可能重大行為變更。

  > 其他資源

ASP.NET Core MVC with EF Core (加強資料庫工具應用.) => ProjectName: ILanUniversity (2021/07/13)
https://docs.microsoft.com/en-us/aspnet/core/data/ef-mvc/?view=aspnetcore-5.0

  1. Create web app
    ProjectName : ILanUniversity
    dotnet new mvc //指令: 新增MVC架構網站(MVC)
    dotnet dev-certs https --trust //指令: 信任測試環境簽章(https用)
    
    2021/07/09
    TODO: 如果要使用登入驗證功能，請參考下列使用說明。
    不然，加入SchoolContext後，在產生DB時會出錯。
    因為，登入驗證功能用的ApplicationContext，也會產生DB。
    https://docs.microsoft.com/zh-tw/aspnet/core/security/authentication/identity?view=aspnetcore-5.0&tabs=visual-studio

   2021/07/09
    找到原因：要遷移後，資料庫才會產生。 
    EF 支援下列模型開發方法：
    從現有的資料庫產生模型。
    將模型手動編寫成符合資料庫的程式碼。
    建立模型之後，請使用 EF 遷移 從模型建立資料庫。 當模型變更時，遷移可讓資料庫演進。

  2. Set up the site style (調整網站風格, 修改名稱, 新增選單...)
    * 調整首頁 Views > Home > Index.cshtml
    * 調整共用版面 Views > Shared > _Layout.cshtml

  3. 安裝ORM套件(EntityFrameworkCore)
      dotnet tool install --global dotnet-ef
      dotnet tool install --global dotnet-aspnet-codegenerator
      dotnet add package Microsoft.EntityFrameworkCore.Design
      dotnet add package Microsoft.EntityFrameworkCore.SQLite
      dotnet add package Microsoft.EntityFrameworkCore.SqlServer
      
      // 自動產生程式碼範本用
      dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
      
      // 協助偵測及診斷EF Core Migration(移轉)的問題
      dotnet add package Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore
  
  4. 新增 Data Model
    * Three Table(Course, Enrollment, Student), 新增3個Entity
      > 1名 Student, 可選多堂課(Enrollment)
      > 1堂 Course, 可被多名學生選取(Enrollment)
    * 若使用 ICollection<T>建立關聯, EFCore 預設會新增 HashSet<T>
    
    * Models.Student.cs
      
      using System;
      using System.Collection.Generic;
      namespace ILanUniversity.Models
      {
        public class Student
        {
          // EFCore會視為PK, 使用自動遞增
          public int ID {get;set;}
          public string LastName {get;set;}
          public string FirstName {get;set;}
          // 範例怪怪的, 選課時間放在學生實體內??
          public DateTime EnrollmentDate {get;set;}

          // Navigation Properties(關聯實體)
          public ICollection<Enrollment> Enrollments {get;set;}
        }
      }

    * Models.Enrollment.cs

      using System;
      namespace ILanUniversity.Models
      {
        public enum Grade
        {
          A, B, C, D, F
        }

        public class Enrollment
        {
          // EFCore會視為PK, 使用自動遞增
          public int EnrollmentID {get;set;}
          public int CourseID {get;set;}
          public int StudentID {get;set;}
          public Grade? Grade {get;set;}

          // Navigation Properties(關聯實體)
          public Course Course {get;set;}
          public Student Student {get;set;}

        }
      }
    * Models.Course.cs

      using System;
      using System.Collections.Generic;
      using System.ComponentModel.DataAnnotations.Schema;
      namespace ILanUniversity.Models
      {
        public class Course
        {
          // 指定使用 CourseID 為PK, 而非使用 EFCore 自動產生的
          // 不會套用自動遞增設定.
          [DatabaseGenerated(DatabaseGeneratedOption.None)]
          public int CourseID {get;set;}
          public string Title {get;set;}
          public int Credits {get;set;}

          // Navigation Properties
          public ICollection<Enrollment> Enrollments {get;set;}
        }
      }

  5. 新增 Database Context
    * DbContext 是 EFCore內最主要的類別, 決定使用哪些 Data Model.
    * 須繼承自 Microsoft.EntityFrameworkCore.DbContext 類別.
    * 1個 entity DbSet 會對應 1個 Table
    * 1個 entity 會對應 1筆 Row
    * EFCore新增DB時, 預設以 {DbSet名稱} 作為 {資料表名稱}
                    , 亦可使用 {程式員指定名稱} 詳下例:

    * Data.SchoolContext.cs

      using ILanUniversity.Models;
      using Microsoft.EntityFrameworkCore;
      namespace ILanUniversity.Data
      {
        public class SchoolContext: DbContext
        {
          // : base(options), 這一段不要漏掉了.
          public SchoolContext(DbContextOptions<SchoolContext> options): base(options)
          {
          }

          public DbSet<Student> Students {get;set;}
          public DbSet<Course> Courses {get;set;}
          public DbSet<Enrollment> Enrollments {get;set;}

          // 不用DbSet名稱作為TableName(預設), 例: Table Students, Courses 有些程式員無法接受.
          // 改以指定名稱新增
          protected override void OnModelCreating(ModelBuilder modelBuilder)
          {
            modelBuilder.Entity<Student>().ToTable("Student");
            modelBuilder.Entity<Course>().ToTable("Course");
            modelBuilder.Entity<Enrollment>().ToTable("Enrollment");
          }
        }
      }

  6. 註冊Database服務
    * .NET Core 使用 DI(依賴性注入), 所以 EFCore Database Context 也要註冊後才能使用.
    * 去哪註冊服務?
      > Startup.cs -> ConfigureServices 方法

    * 範例: Startup.cs

      using ILanUniversity.Data; //放DbContext的地方
      using Microsoft.EntityFrameworkCore; //連接資料庫用套件

      namespace ILanUniversity
      {
        public class Startup
        {
          ...
          public void ConfigureServices(IServiceCollection services)
          {
            if (env.IsDevelopment())
            {
              // 連接SQLite
              services.AddDbContext<SchoolContext>(options => 
              options.UseSqlite(Configuration.GetConnectionString("DefaultConnection")));
            }
            else
            {
              // 連接SQL Server
            services.AddDbContext<SchoolContext>(options => 
              options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
            }            
          }

          // 新增資料庫例外篩選器(Add the database exception filter)
          services.AddDatabaseDeveloperPageExceptionFilter();

          services.AddControllersWithViews();
        }
      }

  7. 新增資料庫例外篩選器(Add the database exception filter)
    * 在開發環境下, 可提供有用的錯誤資訊.
    * 同樣在 > Startup.cs -> ConfigureServices 方法內註冊
    * 範例: 詳上列程式碼

  8. (正式環境) 新增初始移轉 + 匯出SQL Scripts
    dotnet ef migrations add InitialCreate //新增初始移轉 by DbContext
    dotnet ef migrations script //匯出SQL Scripts by Latest Migration
    dotnet ef migrations script --output SqlScripts\InitialCreate.sql //匯出至指定資料夾

    !! 注意 !! SQL Scripts匯出後, 要改寫才能用在SQL Server
      1. 資料表存在否, 語法改寫
          IF OBJECT_ID('__EFMigrationsHistory', 'U') IS NOT NULL
          DROP TABLE __EFMigrationsHistory
          GO
      2. 自動遞增欄位, 語法改寫為 IDENTITY(1,1), 不能用 AUTOINCREMENT
      3. 拿掉所有的 "", 除了新增值或異動值外
          (X)CREATE INDEX "IX_Enrollment_StudentID" ON "Enrollment" ("StudentID");
          (O)CREATE INDEX IX_Enrollment_StudentID ON Enrollment (StudentID);

          (O)INSERT INTO __EFMigrationsHistory (MigrationId, ProductVersion)
          VALUES ('20210713014457_InitialCreate', '5.0.7');
      
    dotnet ef database update //產生資料庫(測試環境用)

  8. (測試環境)資料庫初始化 + 測試資料 (Initialize DB with test data)
    * 撰寫新增初始化資料類別
    * Data.DbInitializer.cs

      using ILanUniversity.Models;
      using System;
      using System.Linq;

      namespace ILanUniversity.Data
      {
        public static class DbInitializer
        {
          public static void Initialize(SchoolContext context)
          {
            // 每次都會刪除資料庫再重新建立, 僅適用於<測試階段>
            context.Database.EnsureCreated();

            // Look for any students.
            if (context.Students.Any())
            {
              return; // DB has been seeded.
            }

            var students = new Student[]
            {
            new Student{FirstMidName="Carson",LastName="Alexander",EnrollmentDate=DateTime.Parse("2005-09-01")},
            new Student{FirstMidName="Meredith",LastName="Alonso",EnrollmentDate=DateTime.Parse("2002-09-01")},
            new Student{FirstMidName="Arturo",LastName="Anand",EnrollmentDate=DateTime.Parse("2003-09-01")},
            new Student{FirstMidName="Gytis",LastName="Barzdukas",EnrollmentDate=DateTime.Parse("2002-09-01")},
            new Student{FirstMidName="Yan",LastName="Li",EnrollmentDate=DateTime.Parse("2002-09-01")},
            new Student{FirstMidName="Peggy",LastName="Justice",EnrollmentDate=DateTime.Parse("2001-09-01")},
            new Student{FirstMidName="Laura",LastName="Norman",EnrollmentDate=DateTime.Parse("2003-09-01")},
            new Student{FirstMidName="Nino",LastName="Olivetto",EnrollmentDate=DateTime.Parse("2005-09-01")}
            };
            foreach (Student s in students)
            {
                context.Students.Add(s);
            }
            context.SaveChanges();

            var courses = new Course[]
            {
            new Course{CourseID=1050,Title="Chemistry",Credits=3},
            new Course{CourseID=4022,Title="Microeconomics",Credits=3},
            new Course{CourseID=4041,Title="Macroeconomics",Credits=3},
            new Course{CourseID=1045,Title="Calculus",Credits=4},
            new Course{CourseID=3141,Title="Trigonometry",Credits=4},
            new Course{CourseID=2021,Title="Composition",Credits=3},
            new Course{CourseID=2042,Title="Literature",Credits=4}
            };
            foreach (Course c in courses)
            {
                context.Courses.Add(c);
            }
            context.SaveChanges();

            var enrollments = new Enrollment[]
            {
            new Enrollment{StudentID=1,CourseID=1050,Grade=Grade.A},
            new Enrollment{StudentID=1,CourseID=4022,Grade=Grade.C},
            new Enrollment{StudentID=1,CourseID=4041,Grade=Grade.B},
            new Enrollment{StudentID=2,CourseID=1045,Grade=Grade.B},
            new Enrollment{StudentID=2,CourseID=3141,Grade=Grade.F},
            new Enrollment{StudentID=2,CourseID=2021,Grade=Grade.F},
            new Enrollment{StudentID=3,CourseID=1050},
            new Enrollment{StudentID=4,CourseID=1050},
            new Enrollment{StudentID=4,CourseID=4022,Grade=Grade.F},
            new Enrollment{StudentID=5,CourseID=4041,Grade=Grade.C},
            new Enrollment{StudentID=6,CourseID=1045},
            new Enrollment{StudentID=7,CourseID=3141,Grade=Grade.A},
            };
            foreach (Enrollment e in enrollments)
            {
                context.Enrollments.Add(e);
            }
            context.SaveChanges();

          }
        }
      }

    * 程式啟動前, {新增初始資料}
    * 更新 Program.cs

      using ILanUniversity.Data;
      using Microsoft.Extensions.DependencyInjection;
      ...

      namespace ILanUniversity
      {
        public class Program
        {
          public static void Main(string[] args)
          {
            var host = CreateHostBuilder(args).Build();
            CreateDbIfNotExists(host);
            host.Run();
          }

          private static void CreateDbIfNotExists(IHost host)
          {
            using (var scope = host.Services.CreateScope())
            {
              var services = scope.ServiceProvider;
              try
              {
                // Get a database context instance from the dependency injection container.
                var context = services.GetRequiredService<SchoolContext>();
                
                // Call the DbInitializer.Initialize method.
                DbInitializer.Initialize(context);
              }
              catch (Exception ex)
              {
                var logger = services.GetRequiredService<ILogger<Program>>();
                logger.LogError(ex, "An error occured during creating the DB.");
              }

              // Dispose the context when the Initialize method completes
            }
          }

          public static IHostBuilder CreateHostBuilder(string[] args) => ...
        }
      }

    * 上述方法, 可在APP首次執行時使用, 新增DB, 塞入Test Data.
    * 但是當{data model變更}時, 則須 (1)刪除DB (2)更新DataSeed函式 (3)新增DB (4)Insert into Test Data.

    !! 之後會說明當 {data model變更} 時, 毋須 {刪除DB & 新增DB} 的方法, 使用 {移轉Migrations from DbContext} !!

  9. {新增Model後}, 自動產生對應的Controller & View 
    * ORM套件要先裝, 不然程式碼生不出來.
    * Model已撰寫完成.
    * 利用 dotnet-aspnet-codegenerator 工具產生程式碼
    * 官方說明: https://docs.microsoft.com/zh-tw/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator?view=aspnetcore-5.0
 
    * 先前範例
      dotnet-aspnet-codegenerator controller // 指定產生控制器
      -name JobsController             // 控制器名稱
      -m Jobs                          // 要使用的模型類別
      -dc JobsContext                  // DbContext要使用的類別 or 要產生的類別名稱
      --relativeFolderPath Controllers //指定相對輸出檔案夾路徑
      --useDefaultLayout               //針對檢視使用預設的配置
      --referenceScriptLibraries       //所產生檢視中的參考指令碼程式庫
  
    * 本專案指令(for Student, Course, Enrollment三個Model)
      dotnet-aspnet-codegenerator controller
      -name StudentsController
      -m Student
      -dc SchoolContext
      --relativeFolderPath Controllers
      --useDefaultLayout      
      --referenceScriptLibraries

      dotnet-aspnet-codegenerator controller -name CoursesController -m Course -dc SchoolContext --relativeFolderPath Controllers --useDefaultLayout --referenceScriptLibraries

      dotnet-aspnet-codegenerator controller -name EnrollmentsController -m Enrollment -dc SchoolContext --relativeFolderPath Controllers --useDefaultLayout --referenceScriptLibraries

  10. 檢視資料庫
    * 資料庫自動產生, 乃依據 Data.DbInitializer.cs
    * 因為使用了 context.Database.EnsureCreated(); // 每次都會刪除資料庫, 僅適用於<測試階段>
      如果Model屬性異動時, 例: Student須多記錄 Email
      > 類別Student 新增屬性Email
      > 刪除資料庫
      > 停止再啟動APP. 資料庫將重新產生
    
    !! 注意, 資料庫重新產生後, 檢視並不會同步更新, 因為工具不同(dotnet-aspnet-codegenerator). !!

  11. 慣例(Conventions)
    * DbContext 的 DbSet 名稱 = 資料表名稱; 
    * DbContext 的 Entity 未被 DbSet 參考時, Entity名稱 = Table Name
    * Entity Property名稱 = Column Name
    * Entity Property名稱 = ID or classnameID時, 將被視為PK
    * Model 內有 navigation property 將被視為FK, 
      FK命名規則1: <navigation property name><PK property name>, 
        例如: navigation property = Student, PK property = ID => FK Name = StudentID
      FK命名規則2: <primary key property name>, 
        例如: Enrollment entity的 PK = EnrollmentID
    
    !! 注意, 上述慣例可被推翻/覆寫, 例如: 指定資料表名稱, 指定PK或FK

  12. 非同步指令碼(aysnchronous code)
    * Asynchronous programming is the default mode for ASP.NET Core and EF Core.
    * 非同步指令碼 可解決因等待I/O完成, 造成執行緒無法充份利用的問題.
    * 非同步指令碼 有成本, 但對於效能改善有實質幫助.

    * 關鍵詞 async, Task<T>, await, ToListAsync 讓程式碼變得非同步.
      public async Task<IActionResult> Index()
      {
        return View(await _context.Students.ToListAsync());
      }
    
    * 實作原理
      The async keyword tells the compiler to generate callbacks for parts of the method body and to automatically create the Task<IActionResult> object that's returned.
      The return type Task<IActionResult> represents ongoing work with a result of type IActionResult.
      The await keyword causes the compiler to split the method into two parts. The first part ends with the operation that's started asynchronously. The second part is put into a callback method that's called when the operation completes.
      ToListAsync is the asynchronous version of the ToList extension method.

    !! 注意事項: 使用 非同步指令碼(aysnchronous code)時
      # 只在{送至資料庫的查詢或指令}上執行非同步.
        正例(須非同步): ToListAsync(取列表), SingleOrDefaultAsync(取第1個值), SaveChangesAsync(儲存)
        反例(不要使用非同步): 單純篩選IQueryable, 例: var students = context.Students.Where(s => s.LastName == "David");

      # EF Context 非執行緒安全, 不要試著平行執行多個作業.
        使用任何 async EFCore 方法, 都要加上 await 關鍵字.

        public async Task<IActionResult> Index()
        {
          // 記得加上 await, 在使用async EFCore 方法時 (ToListAsync())
          return View(await _context.Students.ToListAsync());
        }

      # 確定所有 library package 也使用 async

  13. Limit entities fetched(效能考量)
    * 通常會利用分頁或限制回傳筆數上限, 不會開放隨意筆數回傳.
    * 存取大張資料表時, 可回傳HTTP 200(成功)作為回應, 儘管資料庫存取時出現例外.
    * MaxModelBindingCollectionSize 預設值 = 1024筆, 下列程式碼將值重設為 100
    * Startup.cs
      using Microsoft.AspNetCore.Mvc; //這個要加, For MvcOptions
      public void ConfigureServices(IServiceCollection services)
      {
        var myMaxModelBindingCollectionSize = Convert.ToInt32(
          Configuration["MyMaxModelBindingCollectionSize"] ?? "100");
        services.Configure<MvcOptions>(options => 
          options.MaxModelBindingCollectionSize = myMaxModelBindingCollectionSize);        
        ...
      }
    
    * Configuration["MyMaxModelBindingCollectionSize"]的值去哪抓?
      設定位置: appsetting.{Environment}.json
        {
          "ConnectionStrings": {
            "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=MyDB-2;Trusted_Connection=True;MultipleActiveResultSets=true"
          },
          "MyMaxModelBindingCollectionSize":"50",
          "AllowedHosts": "*"
        }

  14. SQL Logging of EntityFrameworkCore
    * Logging設定通常由 appsetting.{Environment}.json 檔案提供.
    * 如果要記錄 SQL 指令, 請在檔案內 appsettings.json or appsetting.Development.json
      加入以下設定 "Microsoft.EntityFrameworkCore.Database.Command": "Information"
    * appsetting.Development.json 設定範例
      { 
        "Logging": {
          "LogLevel": {
            "Default": "Information",
            "Microsoft": "Warning",
            "Microsoft.Hosting.Lifetime": "Information",
            // 增加下1行, SQL Command 會顯示在 Terminal內.
            "Microsoft.EntityFrameworkCore.Database.Command": "Information"
          }
        },
        "AllowedHosts": "*"
      }      

Entity Framework Core(資料庫工具) (2021/07/12) => ProjectName: EFGetStarted
https://docs.microsoft.com/en-us/ef/core/get-started/overview/first-app?tabs=netcore-cli

  {基本觀念}
    新增專案
      dotnet new console -o <ProjectName>
    
    安裝套件至專案中(存取Sqlite)
      dotnet add package Microsoft.EntityFrameworkCore.Sqlite

    新增模型(Model)
      1. 主類別 : DbContext; 繼承至 DbContext
      2. 資料實體類別, 描述實體屬性及與其他實體間的關係; 例: Student, Course

    新增資料庫(利用migrations移轉來新增DB)
      dotnet tool install --global dotnet-ef //安裝共用工具(dotnet-ef)
      dotnet add package Microsoft.EntityFrameworkCore.Design //安裝套件至專案中(自動產生移轉程式碼用)
      dotnet ef migrations add InitialCreate //產生初始移轉
      dotnet ef database update //依據最近1次移轉, 產生資料庫DB

    利用【主類別 : DbContext】作資料庫異動(CRUD)
      using (var db = new BloggingContext())
      {
        //Create
        db.Add(new Blog{...});
        db.SaveChanges();

        //Read(讀取1筆)
        var blog = db.Blogs.Order.OrderBy(b=>b.BlogId).First();

        //Update
        blog.Url = "https://www.ilan.gov.tw";
        blog.Posts.Add(new Post{ Title="測試", Content="一篇測試文章" }); //新增實體相關子實體項目
        db.SaveChanges(); //儲存變更

        //Delete
        db.Remove(blog); //刪除取出來的Blog實體
        db.SaveChanges(); //儲存變更
      }

  {資料實體屬性細節設定} https://docs.microsoft.com/en-us/ef/core/modeling/
    * 實體屬性無設定時, 會依慣例.
    * 兩種方式可設定實體屬性, 適用優先性(左至右, 由高至低) Fluent API > data annotation(資料註釋) > Conventions(慣例)

      > Fluent API
        * 在你繼承產生的DB主類別中, OnModelCreating 方法內設定
          protected override void OnModelCreating(ModelBuilder modelBuilder)
          {
            modelBuilder.Entity<Blog>()
              .Property(b=>b.Url)
              .IsRequired();

            modelBuilder.Entity<Blog>()
              .Property(b=> b.Comments)
              .HasMaxLength(500);

            modelBuilder.Entity<Blog>()
              .Property(b => b.Title)
              .IsRequired()
              .HasMaxLength(160);
          }
        
        * 若你想簡化 OnModelCreating 方法的程式碼長度, 可利用 Grouping configuration, 將設定獨立為類別檔再引用.
          https://docs.microsoft.com/en-us/ef/core/modeling/#grouping-configuration

      > data annotation(資料註釋)
        * 在資料實體上, 加上註釋
          using System.ComponentModel.DataAnnotations;
          public class Blog
          {
            public int BlogId{get;set;}

            [Required] //加上註釋, 必填欄位
            public string Url{get;set;}

            [Required]
            [MaxLength(500) , MinLength(5)] //多條件限制
            public string Comments {get;set;}

            [Required]
            [StringLength(160)]
            public string Title {get;set;}
          }

  {利用Migrations移轉, 更新Table Schema, 在資料實體改變後}
    * 初版實體
      public class Blog
      {
        public int Id {get;set;}
        public string name {get;set;}
      }

    * 安裝共用工具(dotnet-ef)
      dotnet tool install --global dotnet-ef //安裝共用工具(dotnet-ef)

    * 產生初版移轉(預設放在Migrations資料夾內)
      dotnet ef migrations add InitialCreate

    * (測試環境) 產生資料庫及綱要
      dotnet ef database update //套用最新版migrations, 產生資料庫及綱要
      dotnet ef database update {migrations name} //套用指定migrations, 產生資料庫及綱要.

      !!注意 (SQlite支援)!! 
        1. dotnet ef database update 指令, 不完整, 異動DB上可能出現錯誤
        2. dotnet ef migrations add xxx, OK, 產生移轉沒問題
        
        //亦可用於回溯於之前移轉版本, 有產生資料遺失的風險.

      註: (正式環境) 通常不會使用上述指令直接異動DB，而是【產生SQL Scripts】比較保險
      dotnet ef migrations script                  //採用最新版migrations, 產生SQL Scripts
      dotnet ef migrations script {指定migrations} //From 指定migrations to 最新版migrations, 產生SQL Scripts
      dotnet ef migrations script {From} {To}      //From migrations To migrations, 產生SQL Scripts
    
      註: (正式環境) 產生已套用移轉的【Idempotent SQL scripts】, 常用於確認【套用至DB的最新版移轉】？
      dotnet ef migrations script --idempotent

    * 改版實體
      public class Blog
      {
        public int Id {get;set;}
        public string name {get;set;}
        public DateTime CreatedTimestamp (get;set;) //新增欄位
      }

    * 產生改版移轉
      dotnet ef migrations add AddBlogCreatedTimestamp
    * 改版資料庫及綱要
      dotnet ef database update

    !! 注意: 排除在移轉範圍內 !!
      > 常發生在【主類別: DbContext】 引用 另一個DbContext資料時
      > 請套用下列指令碼, 將 另一個DbContext資料 排除在移轉範圍外

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
          modelBuilder.Entity<IdentityUser>()
            .ToTable("AspNetUsers",t => t.ExcludeFromMigrations());
        }

Introduction to Identity on ASP.NET Core(登入驗證功能) (2021/07/12) => ProjectName: MvcIdentity
dotnet new mvc --auth Individual
https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-5.0&tabs=visual-studio

  * 新增登入驗證功能的MVC專案
    dotnet new mvc --auth Individual

  * 套用移轉, 產生資料庫DB
    dotnet tool install --global dotnet-ef
    dotnet ef database update
  
  * 註冊身分驗證服務 @Startup.cs
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddDbContext<ApplicationDbContext>(options =>
            options.UseSqlite(
                Configuration.GetConnectionString("DefaultConnection")));
        services.AddDatabaseDeveloperPageExceptionFilter();

        services.AddDefaultIdentity<IdentityUser>(options => options.SignIn.RequireConfirmedAccount = true)
            .AddEntityFrameworkStores<ApplicationDbContext>();
        services.AddControllersWithViews();

        // 設定身分驗證服務
        services.Configure<IdentityOptions>(options =>
        {
              // Password settings.
            options.Password.RequireDigit = true;
            options.Password.RequireLowercase = true;
            options.Password.RequireNonAlphanumeric = true;
            options.Password.RequireUppercase = true;
            options.Password.RequiredLength = 6;
            options.Password.RequiredUniqueChars = 1;

            // Lockout settings.
            options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(5);
            options.Lockout.MaxFailedAccessAttempts = 5;
            options.Lockout.AllowedForNewUsers = true;

            // User settings.
            options.User.AllowedUserNameCharacters =
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._@+";
            options.User.RequireUniqueEmail = false;
        });

  * 啟用身分驗證服務 @Startup.cs
    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
            app.UseMigrationsEndPoint();
        }
        else
        {
            app.UseExceptionHandler("/Home/Error");
            // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
            app.UseHsts();
        }
        app.UseHttpsRedirection();
        app.UseStaticFiles();

        app.UseRouting();

        app.UseAuthentication();
        app.UseAuthorization();

        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllerRoute(
                name: "default",
                pattern: "{controller=Home}/{action=Index}/{id?}");
            endpoints.MapRazorPages();
        });
    }

  * 測試身分驗證功能 @XXController.cs

    using Microsoft.AspNetCore.Authorization; //重點

    namespace MvcIdentity.Controllers
    {
        public class HomeController : Controller
        {
            private readonly ILogger<HomeController> _logger;

            public HomeController(ILogger<HomeController> logger)
            {
                _logger = logger;
            }

            public IActionResult Index()
            {
                return View();
            }

            [Authorize] //重點: 登入後才能瀏覽.
            public IActionResult Privacy()
            {
                return View();
            }

            [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
            public IActionResult Error()
            {
                return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
            }
        }
    }


={延後}=

Persist and retrieve relational data with Entity Framework Core (加強資料庫工具應用 => 使用 Azure 環境, 不好實作, 先不作了 2021/07/13)
https://docs.microsoft.com/en-us/learn/modules/persist-data-ef-core/?view=aspnetcore-5.0

Secure an ASP.NET Core web app with the Identity framework (登入驗證功能實作 => 使用 Azure 環境, 不好實作, 先不作了 2021/07/13)
https://docs.microsoft.com/en-us/learn/modules/secure-aspnet-core-identity/?view=aspnetcore-5.0
