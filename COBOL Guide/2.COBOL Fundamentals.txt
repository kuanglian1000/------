2. COBOL Fundamentals(OK)
  This chapter describes the syntax, semantics and usage of the COBOL programming language as implemented by the current version of GnuCOBOL. 
  For the rest of this document the Language is spelt as COBOL to ease reading however the compiler name retains the mixed case of GnuCOBOL.

  This document is intended to serve as a full-function reference and user’s guide suitable for both 
  those readers learning COBOL for the first time as usage as a training tool, 
  as well as those already familiar with some dialects of the COBOL language.
  //本指南讀者為初次學習COBOL人員

  A separate manual exists that just contains the details of the Cobol grammar as implemented in GnuCOBOL
  , which is designed strictly for experienced COBOL programmers and this is taken from this guide. 
  This does NOT contain any training subject matter.
  //還有一份指南是給有經驗的COBOL程式員

  These extra manuals are: GnuCOBOL Quick Reference containing just the COBOL semantics / grammar in a short document while the other
  , GnuCOBOL Sample Programs, shows detailed example Cobol programs with indication of syntax used in each program.
  //另外,還有GnuCOBOL快速指引,說明了COBOL語法及SAMPLE CODE

  For each implementation of the GnuCOBOL compiler the supplied files NEWS should also be read for any last minute updates along with files README and INSTALL for building the compiler.

2.1. The COBOL Language - The Basics
2.1.1. Language Reserved Words(OK)
  Cobol programs consist of a sequence of words and symbols. 
  Words, which consist of sequences of letters (upper- and/or lower-case), digits, dashes (‘-’) and/or underscores (‘_’) may have a pre-defined
  , specific, meaning to the compiler or may be invented by the programmer for his/her purposes.

  The GnuCOBOL language specification defines over 1130 Reserved Words — words to which the compiler assigns a special meaning. 
  This list and number applies to the default list which covers many implementations 
  and that it is possible to limit the list to either a specific implementation via -std=xyz[-strict] or to manually unreserve words 
  if they are used in existing sources as user-defined words.

  Programmers may use a reserved word as part of a word they are creating themselves, 
  but may not create their own word as an exact duplicate (without regard to case) of a COBOL reserved word. 
  Note that a reserved word includes all classes, such as intrinsic functions, mnemonics names, system routines and reserved words. 
  The list of reserved words can be changed 
    by adding or removing specific words for a given compile or as a default by use of the steering command -std and -conf. 
  See the specific config files that are by default, held in /usr/local/share/gnucobol/config. 

  Also using the option ‘FUNCTION ALL INTRINSIC’, will add another 100+ reserved words. 
  These can be modified to match the requirements of a business or project team but be warned 
  that these are updated when a new version of the compiler is built so might be more prudent to create your own configuation 
    based on an existing one but with a different name.

  In addition, you can add and/or remove reserved words by adding one of these options 
    to cobc to add -freserved-words=value or -freserved=word or, 
    to remove, -fnot-reserved=word. 
    As well as -freserved=word:alias to create an alias for a word 
    as well as -fnot-register=word or -fregister=word to remove or add, a special register word.
  //異動GnuCOBOL保留字指令

  See Appendix B - Reserved Word List, for a complete list of GnuCOBOL reserved words .
  //GnuCOBOL的保留字清單,請參閱 Appendix B

  For any given version of GnuCOBOL you can also list the full current set of reserved words 
  by running cobc with --list-reserved, 
    --list-intrinsic, 
    --list-system as well as 
    --list-mnemonics. 
  Again subject to variation depending on usage of the --std line command.
  //列出GnuCOBOL保留字

2.1.2. User-Defined Words(自訂變數)(OK)
  When you write GnuCOBOL programs, you’ll need to create a variety of words to represent various aspects of the program, the program’s data and the external environment in which the program will run. 
  This will include internal names by which data files will be referenced, data item names and names of executable logic procedures.

  User-defined words may be composed from the characters ‘A’ through ‘Z’ (upper- and/or lower-case), ‘0’ through ‘9’, dash (‘-’) and underscore (‘_’). 
  User-defined words may neither start nor end with hyphen or underscore characters.
  //自訂變數可由(A-Z a-z 0-9 - _)所組成 , 但是不能以 - or _ 作為首字元

  Other programming languages provide the programmer with a similar capability of creating their own words (names) for parts of a program; 
  COBOL is somewhat unusual when compared to other languages in that user-defined words may start with a digit.
  //自訂變數不允許以 . 開頭

  With the exception of logic procedure names, which may consist entirely of nothing but digits, user-defined words must contain at least one letter.
  //至少要有 1個字母(A-Z a-z)

2.1.3. Case Insensitivity(COBOL 不分大小寫)(OK)
  All COBOL implementations allow the use of both upper and lower case letters in program coding. 
  GnuCOBOL is completely insensitive to the case used when writing reserved words or user-defined names. 
  Thus, AAAAA, aaaaa, Aaaaa and AaAaA are all the same word as far as GnuCOBOL is concerned.
  //AAAAA, aaaaa, Aaaaa and AaAaA 對COBOL來說 , 是相同的

  The only time the case used does matter is within quoted character strings, where character values will be exactly as coded.
  //區分大小寫的唯一例外 , 在 " 這裡面區有分大小寫 " , ex. "abc" != "ABc"

  By convention throughout this document, 
  COBOL reserved words will be shown entirely in UPPER-CASE while those words 
  that were created by a programmer will be represented by tokens in mixed or lower case.

  This isn’t a bad practice to use in actual programs, 
  as it leads to programs where it is much easier to distinguish reserved words from user-defined ones!
  //原則上 , 雖然COBOL不區分大小寫 , 但建議以 UPPER-CASE 字母表示保留字

2.1.4. Readability of Programs(說明了COBOL程式語言的簡潔)(OK)
  Critics of COBOL frequently focus on the wordiness of the language, 
  often citing the case of a so-called “Hello World” program as the “proof” 
  that COBOL is so much more tedious to program in than more “modern” languages. 
  This tedium is cited as such a significant impact to programmer productivity that, in their opinions, COBOL can’t go away quickly enough.

  Here are two different “Hello World” applications, one written in Java and the second in GnuCOBOL. 
  First, the Java version:

      Class HelloWorld {
          public static void main(String[] args) {
              System.out.println("Hello World!");
          }
      }

  And here is the same program, written in GnuCOBOL:

      IDENTIFICATION DIVISION.
      PROGRAM-ID. HelloWorld.
      PROCEDURE DIVISION.
          DISPLAY "Hello World!".

  Both of the above programs could have been written on a single line, if desired, 
  and both languages allow a programmer to use (or not use) indentation as they see fit to improve program readability. 
  Sounds like a tie so far.

  Let’s look at how much more “wordy” COBOL is than Java. 
  Count the characters in the two programs. 
  The Java program has 95 (not counting carriage returns and any indentation). 
  The COBOL program has 89 (again, not counting carriage returns and indentation)! 
  Technically, it could have been only 65 because the IDENTIFICATION DIVISION. header is actually optional. Clearly, “Hello World” doesn’t look any more concise in Java than it does in COBOL.

  Let’s look at a different problem. 
  Surely a program that asks a user to input a positive integer, 
  generates the sum of all positive integers from 1 to that number 
  and then prints the result will be MUCH shorter and MUCH easier to understand when coded in Java than in COBOL, right?

  You can be the judge. First, the Java version:

      import java.util.Scanner;
      public class sumofintegers {
          public static void main(String[] arg) {
              System.out.println("Enter a positive integer");
              Scanner scan=new Scanner(System.in);
              int n=scan.nextInt();
              int sum=0;
              for (int i=1;i<=n;i++) {
                  sum+=i;
              }
              System.out.println("The sum is "+sum);
          }
      }
  And now for the COBOL version:

      IDENTIFICATION DIVISION.
      PROGRAM-ID. SumOfIntegers.
      DATA DIVISION.
      WORKING-STORAGE SECTION.
      01 n   BINARY-LONG.
      01 i   BINARY-LONG.
      01 sum BINARY-LONG VALUE 0.
      PROCEDURE DIVISION.
      DISPLAY "Enter a positive integer"
      ACCEPT n
      PERFORM VARYING i FROM 1 BY 1 UNTIL i > n
          ADD i TO sum
      END-PERFORM
      DISPLAY "The sum is " sum.

  My familiarity with COBOL may be prejudicing my opinion, but it doesn’t appear to me that the Java code is any simpler than the COBOL code. 
  In case you’re interested in character counts, the Java code comes in at 278 (not counting indentation characters). 
  The COBOL code is 298 (274 without the IDENTIFICATION DIVISION. header).

  Despite what you’ve seen here, the more complex the programming logic being implemented, 
  the more concise the Java code will appear to be, even compared to 2002-standard COBOL. 
  That conciseness comes with a price though — program code readability. 
  Java (or C or C++ or C#) programs are generally intelligible only to trained programmers. 
  COBOL programs can, however, be quite understandable by non-programmers. 
  This is actually a side-effect of the “wordiness” of the language, 
  where COBOL statements use natural English words to describe their actions. 
  This inherent readability has come in handy many times throughout my career 
  when I’ve had to learn obscure business (or legal) processes by reading the COBOL program code that supports them.

  The “modern” languages, like Java, also have their own “boilerplate” infrastructure overhead 
  that must be coded in order to write the logic that is necessary in the program. Take for example the public static void main(String[] arg) and import java.util.Scanner; statements. The critics tend to forget about this when they criticize COBOL for its structural “overhead”.

  When it first was developed, COBOL’s easily-readable syntax made it profoundly different from anything that had been seen before. For the first time, it was possible to specify logic in a manner that was — at least to some extent — comprehensible even to non-programmers. Take for example, the following code written in FORTRAN — a language developed only a year before COBOL:

      EXT = PRICE * IQTY
      INVTOT = INVTOT + EXT

  With its original limitation on the length of variable names (one- to six-character names comprised of a letter followed by up to five letters and/or digits), its implicit rule that variables were automatically created as real (floating-point) unless their name started with a letter in the range I-N, and its use of algebraic notation to express actions being taken, FORTRAN wasn’t a particularly readable language, even for programmers. Compare this with the equivalent COBOL code:

      MULTIPLY price BY quantity GIVING extended-amount
      ADD extended-amount TO invoice-total

  Clearly, even a non-programmer could at least conceptually understand what was going on! 
  Over time, languages like FORTRAN evolved more robust variable names, and COBOL introduced a more formula-based syntactical capability for arithmetic operations, 
  but FORTRAN was never as readable as COBOL.

  Because of its inherent readability, 
  I would MUCH rather be handed an assignment to make significant changes to a COBOL program about 
  which I know nothing than to be asked to do the same with a C, C++, C# or Java program.

  Those that argue that it is too boring / wasteful / time-consuming / insulting (pick one) 
  to have to code a COBOL program “from scratch” are clearly ignorant of the following facts:

  Many systems have program-development tools available to ease the task of coding programs; 
  those tools that concentrate on COBOL are capable of providing templates for much of the “overhead” verbiage of any program…
  Good programmers have — for decades — maintained their own skeleton “template” programs for a variety of program types; 
  simply load a template into a text editor and you’ve got a good start to the program…

  Legend has it that there’s actually only been ONE program ever written in COBOL
  , and all programs ever “written” thereafter were simply derivatives of that one. 
  Although this is clearly intended as a (probably) bad joke, 
  it is nevertheless close to the very simple truth that many programmers“reuse” existing COBOL programs when creating new ones. 
  There’s certainly nothing preventing this from happening with programs written in other languages, 
  but it does seem to happen more in COBOL shops. 

  It’s ironic that “code re-usability” is one of the arguments used to justify the existence of the “modern” languages.

2.1.5. Divisions Organize Programs(COBOL程式的組成 , 4個主要區塊 divisions / sections / paragraphs / statements)(OK)
  COBOL programs are structured into four major areas of coding, each with its own purpose. These four areas are known as divisions.
  Each division may consist of a variety of sections and each section consists of one or more paragraphs. 
  A paragraph consists of sentences, each of which consists of one or more statements.

  This hierarchical structure of program components standardizes the composition of all COBOL programs. 
  Much of this manual describes the various divisions, sections, paragraphs and statements that may comprise any COBOL program. COPY statement (see COPY)

2.1.6. Copybooks(COPY and REPLACE 功能,如同新一代語言的 "import" , "include")(OK)
  A Copybook is a segment of program code that may be utilized by multiple programs simply by having those programs use the COPY statement to import that code. 
  This code may define files, data structures or procedural code.

  Today’s current programming languages have a statement (usually, this statement is named “import”, “include” or “#include”) that performs this same function. 
  What makes the COBOL copybook feature different than the “include” facility in newer languages, 
  however, is the fact that the COPY statement can edit the imported source code as it is being copied. 
  This capability makes copybook libraries extremely valuable to making code reusable. 
  Also see section 3. Compiler Directing Facility commands COPY and REPLACE.

2.1.7. Structured Data(像是變數宣告,對於COBOL而言,它可由多個資料區塊所組成. 例: 'Employee-Name' = 'Last-Name' + '-' + 'First-Name')(OK)
  A contiguous area of storage within the memory space of a program that may be referenced, by name, in a COBOL program is referred to as a Data Item. 
  Other programming languages use the term variable, property or attribute to describe the same thing.

  COBOL introduced the concept of structured data. 
  The principle of structured data in COBOL is based on the idea of being able to group related and contiguously-allocated data items together into a single aggregate data item, 
  called a Group Item. 
  For example, a 35-character ’Employee-Name’ group item might consist of a 20-character ’Last-Name’ followed by a 14-character ’First-Name’ and a 1-character ’Middle-Initial’.

  A data item that isn’t itself formed from other data items is referred to in COBOL as an Elementary Item. 
  In the previous example, ’Last-Name’, ’First-Name’ and ’Middle-Initial’ are all elementary items.

2.1.8. Files
One of COBOL’s strengths is the wide variety of data files it is capable of accessing. 
GnuCOBOL programs, like those created with other COBOL implementations, need to have the structure of any files they will be reading and/or writing described to them. 
The highest-level characteristic of a file’s structure is defined by specifying the organization of the file, as follows:

ORGANIZATION LINE SEQUENTIAL(必須從頭讀到尾,每行結尾有固定符號 ; WRITE <BEFORE ADVANCING 1 LINE>)(OK)
  These are files with the simplest of all internal structures. Their contents are structured simply as a series of identically- or differently-sized data records, 
  each terminated by a special end-of-record delimiter character. 
  An ASCII line-feed character (hexadecimal 0A) is the end-of-record delimiter character used by any UNIX or pseudo-UNIX (MinGW, Cygwin, OSX) GnuCOBOL build. 
  A truly native Windows build would use a carriage-return, line-feed (hexadecimal 0D0A) sequence.

  Records must be read from or written to these files in a purely sequential manner. 
  The only way to read (or write) record number 100 would be to have read (or written) records number 1 through 99 first.

  When the file is written to by a GnuCOBOL program, the delimiter sequence will be automatically appended to each data record as it is written to the file. 
  A WRITE (see WRITE) to this type of file will be done as if a <BEFORE ADVANCING 1 LINE> clause were specified on the WRITE, if no ADVANCING clause is coded.

  When the file is read, the GnuCOBOL runtime system will strip the trailing delimiter sequence from each record. 
  The data will be padded (on the right) with spaces if the data just read is shorter than the area described for data records in the program. 
  If the data is too long, it will be truncated and the excess will be lost.

  These files should not be defined to contain any exact binary data fields (只能包含binary data fields)
  because the contents of those fields could inadvertently have the end-of-record sequence as part of their values — this would confuse the runtime system when reading the file, 
  and it would interpret that value as an actual end-of-record sequence.

LINE ADVANCING(和ORGANIZATION LINE SEQUENTIAL唯一的差異在於 不用明確指定 ORGANIZATION ; WRITE <AFTER ADVANCING 1 LINE> )(OK)
  These are files with an internal structure similar to that of a line sequential file. 
  These files are defined (without an explicit ORGANIZATION specification) using the LINE ADVANCING clause on their SELECT statement (see SELECT).

  When this kind of file is written to by a GnuCOBOL program, an end-of-record delimiter sequence will be automatically added to each data record as it is written to the file. 
  A WRITE to this type of file will be done as if an <AFTER ADVANCING 1 LINE> clause were specified on the WRITE, if no ADVANCING clause is coded.

  Like line sequential files, these files should not be defined to contain any exact binary data fields because the contents of those fields could inadvertently have the end-of-record sequence as part of their values — this would confuse the runtime system when reading the file, and it would interpret that value as an actual end-of-record sequence.

ORGANIZATION SEQUENTIAL(固定每行長度,每行沒有結尾符號)
(例:定義每行長度為 100 characters,有1個檔案資料內容有 1275 characters, 則這個檔案會被拆成 12行 + 最後1行 75 characters)

These files also have a simple internal structure. 
Their contents are structured simply as an arbitrarily-long sequence of data characters. 
This sequence of characters will be treated as a series of fixed-length records simply by logically splitting the sequence of characters up into fixed-length segments, 
each as long as the maximum record size defined in the program. 

There are no special end-of-record delimiter characters in the file and when the file is written to by a GnuCOBOL program, no delimiter sequence is appended to the data.
Records in this type of file are all the same physical length, except possibly for the very last record in the file, which may be shorter than the others. 
If variable-length logical records are defined to the program, 
the space occupied by each physical record in the file will occupy the space described by the longest record description in the program.

So, if a file contains 1275 characters of data, and a program defines the structure of that file as containing 100-character records, 
then the file contents will consist of twelve (12) 100-character records with a final record containing only 75 characters.
(例:定義每行長度為 100 characters,有1個檔案資料內容有 1275 characters, 則這個檔案會被拆成 12行 + 最後1行 75 characters)

It would appear that it should be possible to locate and process any record in the file directly simply by calculating its starting character position based upon the program-defined record size. Even so, however, records must be still be read or written to these files in a purely sequential manner. The only way to read (or write) record number 100 would be to have read (or written) records number 1 through 99 first.

When the file is read, the data is transferred into the program exactly as it exists in the file. In the event that a short record is read as the very last record, that record will be padded (to the right) with spaces.

Care must be taken that programs reading such a file describe records whose length is exactly the same as that used by the program that created the file. For example, the following shows the contents of a SEQUENTIAL file created by a program that wrote five 6-character records to it. The ‘A’, ‘B’, … values reflect the records that were written to the file:

‘AAAAAA’
‘BBBBBB’
‘CCCCCC’
‘DDDDDD’
‘EEEEEE’
Now, assume that another program reads this file, but describes 10-character records rather than 6. Here are the records that program will read:

‘AAAAAABBBB’
‘BBCCCCCCDD’
‘DDDDEEEEEE’
There may be times where this is exactly what you were looking for. More often than not, however, this is not desirable behaviour. Suggestion: use a copybook to describe the record layouts of any file; this guarantees that multiple programs accessing that file will “see” the same record sizes and layouts by coding a COPY statement (see COPY) to import the record layout(s) rather than hand-coding them.

These files can contain exact binary data fields. Because there is no character sequence that constitutes an end-of-record delimiter, the contents of record fields are irrelevant to the reading process.

ORGANIZATION RELATIVE
The contents of these files consist of a series of fixed-length data records prefixed with a four-byte record header. The record header contains the length of the data, in bytes. The byte-count does not include the four-byte record header.

Records in this type of file are all the same physical length. If variable-length logical records are defined to the program, the space occupied by each physical record in the file will occupy the maximum possible space, and the logical record length field will contain the number of bytes of data in the record that are actually in use.

This file organization was defined to accommodate either sequential or random processing. With a RELATIVE file, it is possible to read or write record 100 directly, without having to have first read or written records 1-99. The GnuCOBOL runtime system uses the program-defined maximum record size to calculate a relative byte position in the file where the record header and data begin, and then transfers the necessary data to or from the program.

When the file is written by a GnuCOBOL program, no delimiter sequence is appended to the data, but a record-length field is added to the beginning of each physical record.

When the file is read, the data is transferred into the program exactly as it exists in the file.

Care must be taken that programs reading such a file describe records whose length is exactly the same as that used by the programs that created the file. It won’t end well if the GnuCOBOL runtime library interprets a four-byte ASCII character string as a record length when it transfers data from the file into the program!

Suggestion: use a copybook to describe the record layouts of any file; this guarantees that multiple programs accessing that file will “see” the same record sizes and layouts by coding a COPY statement (see COPY) to import the record layout(s) rather than hand-coding them.

These files can contain exact binary data fields. The contents of record fields are irrelevant to the reading process as there is no end-of-record delimiter.

ORGANIZATION INDEXED
This is the most advanced file structure available to GnuCOBOL programs. It’s not possible to describe the physical structure of such files because that structure will vary depending upon which advanced file-management facility was included into the GnuCOBOL build you will be using (Berkeley Database [BDB], VBISAM, etc.). We will — instead — discuss the logical structure of the file.

There will be multiple structures stored for an INDEXED file. The first will be a data component, which may be thought of as being similar to the internal structure of a relative file. Data records may not, however, be directly accessed by their record number as would be the case with a relative file, nor may they be processed sequentially by their physical sequence in the file.

The remaining structures will be one or more index components. An index component is a data structure that (somehow) enables the contents of a field, called a primary key, within each data record (a customer number, an employee number, a product code, a name, etc.) to be converted to a record number so that the data record for any given primary key value can be directly read, written and/or deleted. Additionally, the index data structure is defined in such a manner as to allow the file to be processed sequentially, record-by-record, in ascending sequence of the primary key field values. Whether this index structure exists as a binary-searchable tree structure (b-tree), an elaborate hash structure or something else is pretty much irrelevant to the programmer — the behaviour of the structure will be as it was just described. The actual mechanism used will depend upon the advanced file-management package was included into your GnuCOBOL implementation when it was built.

The runtime system will not allow two records to be written to an indexed file with the same primary key value.

The capability exists for an additional field to be defined as what is known as an alternate key. Alternate key fields behave just like primary keys, allowing both direct and sequential access to record data based upon the alternate key field values, with one exception. That exception is the fact that alternate keys may be allowed to have duplicate values, depending upon how the alternate key field is described to the GnuCOBOL compiler.

There may be any number of alternate keys, but each key field comes with a disk space penalty as well as an execution time penalty. As the number of alternate key fields increases, it will take longer and longer to write and/or modify records in the file.

These files can contain exact binary data fields. The contents of record fields are irrelevant to the reading process as there is no end-of-record delimiter.

All files are initially described to a GnuCOBOL program using a SELECT statement (see SELECT). In addition to defining a name by which the file will be referenced within the program, the SELECT statement will specify the name and path by which the file will be known to the operating system along with its organization, locking and sharing attributes.

A file description in the FILE SECTION (see FILE SECTION) will define the structure of records within the file, including whether or not variable-length records are possible and, if so, what the minimum and maximum length might be. In addition, the file description entry can specify file I/O block sizes.

2.1.9. Table Handling
Other programming languages have arrays; COBOL has tables. They’re basically the same thing. There are two special statements that exist in the COBOL language — SEARCH and SEARCH ALL — that make finding data in a table easy.

SEARCH searches a table sequentially, stopping only when either a table entry matching one of any number of search conditions is found, or when all table entries have been checked against the search criteria and none matched any of those criteria.

SEARCH ALL performs an extremely fast search against a table sorted by a key field contained in each table entry. The algorithm used for such a search is a binary search. The algorithm ensures that only a small number of entries in the table need to be checked in order to find a desired entry or to determine that the desired entry doesn’t exist in the table. The larger the table, the more effective this search becomes. For example, a binary search of a table containing 32,768 entries will locate a particular entry or determine the entry doesn’t exist by looking at no more than fifteen (15) entries! The algorithm is explained in detail in the documentation of the SEARCH ALL statement (see SEARCH ALL).

Finally, COBOL has the ability to perform in-place sorts of the data that is found in a table.

2.1.10. Sorting and Merging Data
The COBOL language includes a powerful SORT statement that can sort large amounts of data according to arbitrarily complex key structures. This data may originate from within the program or may be contained in one or more external files. The sorted data may be written automatically to one or more output files or may be processed, record-by-record in the sorted sequence.

A companion statement — MERGE — can combine the contents of multiple files together, provided those files are all pre-sorted in a similar manner according to the same key structure. The resulting output will consist of the contents of all of the input files, merged together and sequenced according to the common key structure(s). The output generated by a MERGE statement may be written automatically to one or more output files or may be processed internally by the program.

A special form of the SORT statement also exists just to sort the data that resides in a table. This is particularly useful if you wish to use SEARCH ALL against the table.

2.1.11. String Manipulation
There have been programming languages designed specifically for the processing of text strings, and there have been programming languages designed for the sole purpose of performing high-powered numerical computations. Most programming languages fall somewhere in the middle.

COBOL is no exception, although it does include some very powerful string manipulation capabilities; GnuCOBOL actually has even more string-manipulation capabilities than many other COBOL implementations. The following summarizes GnuCOBOL’s string-processing capabilities:

Concatenate two or more strings
CONCATENATE intrinsic function (see CONCATENATE).
STRING statement (see STRING).
Conversion of a numeric time or date to a formatted character string
LOCALE-TIME intrinsic function (see LOCALE-TIME).
LOCALE-DATE intrinsic function (see LOCALE-DATE).
Convert a binary value to its corresponding character in the program’s character set
CHAR intrinsic function (see CHAR). Add 1 to argument before invoking the function; the description of the CHAR intrinsic function presents a technique utilizing the MOVE statement that will accomplish the same thing without the need of adding 1 to the numeric argument value first.
Convert a character string to lower-case
LOWER-CASE intrinsic function (see LOWER-CASE).
C$TOLOWER built-in system subroutine (see C$TOLOWER).
CBL_TOLOWER built-in system subroutine (see CBL_TOLOWER).
Convert a character string to upper-case
UPPER-CASE intrinsic function (see UPPER-CASE).
C$TOUPPER built-in system subroutine (see C$TOUPPER).
CBL_TOUPPER built-in system subroutine (see CBL_TOUPPER).
Convert a character string to only printable characters
C$PRINTABLE built-in system subroutine (see C$PRINTABLE).
Convert a character to its numeric value in the program’s character set
ORD intrinsic function (see ORD). Subtract 1 from the result; the description of the ORD intrinsic function presents a technique utilizing the MOVE statement that will accomplish the same thing without the need of adding 1 to the numeric argument value first.
Count occurrences of sub strings in a larger string
INSPECT statement (see INSPECT) with the TALLYING clause.
Decode a formatted numeric string back to a numeric value
NUMVAL intrinsic function (see NUMVAL).
NUMVAL-C intrinsic function (see NUMVAL-C).
Determine the length of a string or data-item capable of storing strings
LENGTH intrinsic function (see LENGTH).
BYTE-LENGTH intrinsic function (see BYTE-LENGTH).
Extract a sub string from a string based on its starting character position and length
Use of a reference modifier on the string field - See Reference Modifiers.
Format a numeric item for output, including thousands-separators (‘,’ in the USA), currency symbols (‘$’ in the USA), decimal points, credit/Debit Symbols, Leading Or Trailing Sign Characters
MOVE statement (see MOVE) with picture-symbol editing applied to the receiving field:
Justification (left, right or centred) of a string field
C$JUSTIFY built-in system subroutine (see C$JUSTIFY).
Monoalphabetic substitution of one or more characters in a string with different characters
INSPECT statement (see INSPECT) with the CONVERTING.
TRANSFORM statement (see TRANSFORM).
SUBSTITUTE intrinsic function (see SUBSTITUTE).
SUBSTITUTE-CASE intrinsic function (see SUBSTITUTE-CASE).
Parse a string, breaking it up into sub strings based upon one or more delimiting character sequences1
UNSTRING statement (see UNSTRING).
Removal of leading or trailing spaces from a string
TRIM intrinsic function (see TRIM).
Substitution of a single sub string with another of the same length, based upon the sub strings starting character position and length
MOVE statement (see MOVE) with a reference modifier on the “receiving” field (see Reference Modifiers).
Substitution of one or more sub strings in a string with replacement sub strings of the same length, regardless of where they occur
INSPECT statement (see INSPECT) with a REPLACING clause.
SUBSTITUTE intrinsic function (see SUBSTITUTE).
SUBSTITUTE-CASE intrinsic function (see SUBSTITUTE-CASE).
Substitution of one or more sub strings in a string with replacement sub strings of a potentially different length, regardless of where they occur
SUBSTITUTE intrinsic function (see SUBSTITUTE).
SUBSTITUTE-CASE intrinsic function (see SUBSTITUTE-CASE).
2.1.12. Screen Formatting Features
The COBOL2002 standard formalizes extensions to the COBOL language that allow for the definition and processing of text-based screens, as is a typical function on mainframe and midframe computers as well as on many point-of-sale (i.e. “cash register”) systems. GnuCOBOL implements virtually all the screen-handling features described by COBOL2002.

These features allow fields to be displayed at specific row/column positions, various colors and video attributes to be assigned to screen fields and the pressing of specific function keys (F1, F2, …) to be detectable. All of this takes place through the auspices of the SCREEN SECTION (see SCREEN SECTION) and special formats of the ACCEPT statement (see ACCEPT) and the DISPLAY statement (see DISPLAY).

The COBOL2002 standard, and therefore GnuCOBOL, only covers textual user interface (TUI) screens (those comprised of ASCII characters presented using a variety of visual attributes) and not the more-advanced graphical user interface (GUI) screen design and processing capabilities built into most modern operating systems. There are subroutine-based packages available that can do full GUI presentation — most of which may be called by GnuCOBOL programs, with a moderate research time investment (Tcl/Tk, for example) — but none are currently included with GnuCOBOL.

2.1.12.1. A Sample Screen
A Sample Screen Produced by a GnuCOBOL Program:

================================================================================
 GCic (2014/01/02 11:24) GnuCOBOL 2.1 23NOV2013 Interactive Compilation
+------------------------------------------------------------------------------+
: Filename: GCic.cbl                                                           :
: Folder:   E:\Programs\GCic\2013-11-23                                        :
+------------------------------------------------------------------------------+
 Set/Clr Switches Via F1-F9; Set Config Via F12; ENTER Key Compiles; ESC Quits
+------------------------------------------------------------------------------+
: F1  Assume WITH DEBUGGING MODE  F6 >"FUNCTION" Is Optional      : Current    :
: F2  Procedure+Statement Trace   F7 >Enable All Warnings         : Config:    :
: F3  Make a Library (DLL)        F8  Source Is Free-Format       : DEFAULT    :
: F4  Execute If Compilation OK   F9 >No COMP/BINARY Truncation   :            :
: F5  Listing Off                                                 :            :
+------------------------------------------------------------------------------+
 Extra "cobc" Switches, If Any ("-save-temps=xxx" Prevents Listings):
+------------------------------------------------------------------------------+
: ____________________________________________________________________________ :
: ____________________________________________________________________________ :
+------------------------------------------------------------------------------+
 Program Execution Arguments, If Any:
+------------------------------------------------------------------------------+
: ____________________________________________________________________________ :
: ____________________________________________________________________________ :
+------------------------------------------------------------------------------+
 GCic for Windows/MinGW Copyright (C) 2009-2014, Gary L. Cutler, GPL
================================================================================
The above screen was produced by the GnuCOBOL Interactive Compiler, or GCic. See GCic in GnuCOBOL Sample Programs, for the source and cross-reference listing of this program. PDF versions of this document will include an actual graphical image of this sample screen.

Screens are defined in the screen section of the data division. Once defined, screens are used at run-time via the ACCEPT and DISPLAY statements.

2.1.12.2. Color Palette and Video Attributes
GnuCOBOL supports the following visual attribute specifications in the SCREEN SECTION (see SCREEN SECTION):

Color
Eight (8) different colors may be specified for both the background (screen) and foreground (text) color of any row/column position on the screen. Colors are specified by number, although a copybook supplied with all GnuCOBOL distributions (screenio.cpy) defines COB-COLOR-xxxxxx names for the various colors so they may be specified as a more meaningful name rather than a number. The eight colors, by number, with the constant names defined in screenio.cpy, are as follows:

Black
COB-COLOR-BLACK

Blue
COB-COLOR-BLUE

Green
COB-COLOR-GREEN

Cyan
COB-COLOR-CYAN

Red
COB-COLOR-RED

Magenta
COB-COLOR-MAGENTA

Yellow
COB-COLOR-YELLOW

White
COB-COLOR-WHITE

Text Brightness
There are three possible brightness levels supported for text — lowlight (dim), normal and highlight (bright). Not all GnuCOBOL implementations will support all three (some treat lowlight the same as normal). The deciding factor as to whether two or three levels are supported lies with the version of the curses package that is being used. This is a utility screen-IO package that is included into the GnuCOBOL run-time library when the GnuCOBOL software is built.

As a general rule of thumb, Windows implementations support two levels while Unix ones support all three.

Blinking
This too is a video feature that is dependent upon the curses package built into your version of GnuCOBOL. If blinking is enabled in that package, text displayed in fields defined in the screen section as being blinking will endlessly cycle between the brightest possible setting (highlight) and an “invisible” setting where the text color matches that of the field background color. A Windows build, which generally uses the “pcurses” package, will uses a brighter-than-normal background color to signify “blinking”.

Reverse Video
This video attribute simply swaps the foreground and background colors and display options.

Field Outlining
It is possible, if supported by the curses package being used, to draw borders on the top, left and/or bottom edges of a field.

Secure Input
If desired, screen fields used as input fields may defined as “secure” fields, where each input character (regardless of what was actually typed) will appear as an asterisk (*) character. The actual character whose key was pressed will still be stored into the field in the program, however. This is very useful for password or account number fields.

Prompt Character
Input fields may have any character used as a fill character. These fill characters provide a visual indication of the size of the input field, and will automatically be transformed into spaces when the input field is processed by the program. If no such character is defined for an input field, an underscore (‘_’) will be assumed.

2.1.13. Report Writer Features
GnuCOBOL includes an implementation of the Report Writer Control System, or RWCS. The reportwriter module is now fully implemented as of version 3.0. This is a standardized, optional add-on feature to the COBOL language which automates much of the mechanics involved in the generation of printed reports by:

Controlling the pagination of reports, including:
The automatic production of a one-time notice on the first page of the report (report heading).
The production of zero or more header lines at the top of every page of the report (page heading).
The production of zero or more footer lines at the bottom of every page of the report (page footing).
The automatic numbering of printed pages.
The formatting of those report lines that make up the main body of the report (detail).
Full awareness of where the “pen” is about to “write” on the current page, automatically forcing an eject to a new page, along with the automatic generation of a page footer to close the old page and/or a page header to begin the new one.
The production of a one-time notice at the end of the last page of a report (report footing).
Performing special reporting actions based upon the fact that the data being used to generate the report has been sorted according to one or more key fields:
Automatically suppressing the presentation of one or more fields of data from the detail group when the value(s) of the field(s) duplicate those of the previously generated detail group. Fields such as these are referred to as group-indicate fields.
Automatically causing suppressed detail group-indicate fields to re-appear should a detail group be printed on a new page.
Recognizing when control fields on the report — fields tied to those that were used as SORT statement (see SORT) keys — have changed. This is known as a control break. The RWCS can automatically perform the following reporting actions when a control break occurs:
Producing a footer, known as a control footing after the detail lines that shared the same old value for the control field.
Producing a header, known as a control heading before the detail lines that share the same new value for the control field.
Perform data summarise, as follows:
Automatically generating subtotals in control and/or report footings, summarizing values of any fields in the detail group.
Automatically generating crossfoot totals in detail groups. These would be sums of two or more values presented in the detail group.
The REPORT SECTION (see REPORT SECTION) documentation explores the description of reports and the PROCEDURE DIVISION (see PROCEDURE DIVISION) chapter documents the various language statements that actually produce reports. Before reading these, you might find it helpful to read Report Writer Usage, which is dedicated to putting the pieces together for you.

2.1.14. Data Initialization
There are three ways in which data division data gets initialized.

When a program or subprogram is first executed, much of the data in its data division will be initialized as follows:
Alphanumeric and alphabetic (i.e. text) data items will be initialized to SPACES.
Numeric data items will be initialized to a value of ZERO.
Data items with an explicit VALUE (see VALUE) clause in their definition will be initialized to that specific value.
The various sections of the data division each have their own rules as to when the actions described above will occur — consult the documentation on those sections for additional information.

These default initialization rules can vary quite substantially from one COBOL implementation to another. For example, it is quite common for data division storage to be initialized to all binary zeros except for those data items where VALUE clauses are present. Take care when working with applications originally developed for another COBOL implementation to ensure that GnuCOBOL’s default initialization rules won’t prove disruptive.

A programmer may use the INITIALIZE statement (see INITIALIZE) to initialise any group or elementary data item at any time. This statement provides far more initialization options than just the simple rules stated above.
When the ALLOCATE statement (see ALLOCATE) statement is used to allocate a data item or to simply allocate an area of storage of a size specified on the ALLOCATE, that allocation may occur with or without initialization, as per the programmer’s needs.
2.1.15. Syntax Diagram Conventions
Syntax of the GnuCOBOL language will be described in special syntax diagrams using the following syntactical-description techniques:

MANDATORY-RESERVED-WORD
~~~~~~~~~~~~~~~~~~~~~~~
Reserved words of the COBOL language will appear in UPPER-CASE. When they appear underlined, as this one is, they are required reserved words.

OPTIONAL-RESERVED-WORD
When reserved words appear without underlining, as this one is, they are optional; such reserved words are available in the language syntax merely to improve readability — their presence or absence has no effect upon the program.

ABBREVIATION
~~~~
When only a portion of a reserved word is underlined, it indicates that the word may either be coded in its full form or may be abbreviated to the portion that is underlined.

substitutable-items
Generic terms representing user-defined substitutable items will be shown entirely in lower-case in syntax diagrams. When such items are referenced in text, they will appear as substitutable-items.

Complex-Syntax-Clause
Items appearing in Mixed Case within a syntax diagram represent complex clauses of other syntax elements that may appear in that position. Some COBOL syntax gets quite complicated, and using a convention such as this significantly reduces the complexity of a syntax diagram. When such items are referenced in text, they will appear as Complex-Syntax-Clause.

[ ]
Square bracket meta characters on syntax diagrams document language syntax that is optional. The [] characters themselves should not be coded. If a syntax diagram contains ‘a [b] c’, the ‘a’ and ‘c’ syntax elements are mandatory but the ‘b’ element is optional.

|
Vertical bar meta characters on syntax diagrams document simple choices. The | character itself should not be coded. If a syntax diagram contains ‘a|b|c’, exactly one of the items ‘a’, ‘b’ or ‘c’ must be selected.

{ xxxxxx }
{ yyyyyy }
{ zzzzzz }
A vertical list of items, bounded by multiple brace characters, is another way of signifying a choice between a series of items where exactly one item must be selected. This form is used to show choices when one or more of the selections is more complex than just a single word, or when there are too many choices to present horizontally with ‘|’ meta characters.

| xxxxxx |
| yyyyyy |
| zzzzzz |
A vertical list of items, bounded by multiple vertical bar characters, signifies a choice between a series of items where one or more of the choices could be selected.

...
The ... meta character sequence signifies that the syntax element immediately preceding it may be repeated. The ... sequence itself should not be coded. If a syntax diagram contains a b... c, syntax element ‘a’ must be followed by at least one ‘b’ element (possibly more) and the entire sequence must be terminated by a ‘c’ syntax element.

{ }
The braces (‘{’ and ‘}’) meta characters may be used to group a sequence of syntax elements together so that they may be treated as a single entity. The {} characters themselves should not be coded. These are typically used in combination with the ‘|’ or ‘...’ meta characters.

$*^()-+=:"'<,>./
Any of these characters appearing within a syntax diagram are to be interpreted literally, and are characters that must be coded — where allowed — in the statement whose format is being described. Note that a ‘.’ character is a literal character that must be coded on a statement whereas a ‘...’ symbol is the meta character sequence described above.

2.1.16. Format of Program Source Lines
Prior to the COBOL2002 standard, source statements in COBOL programs were structured around 80-column punched cards. This means that each source line in a COBOL program consisted of five different “areas”, defined by their column number(s).

As of the COBOL2002 standard, a second mode now exists for COBOL source code statements — in this mode of operation, COBOL statements may each be up to 255 characters long, with no specific requirements as to what should appear in which columns.

Of course, in keeping with the long-standing COBOL tradition of maintaining backwards compatibility with older standards, programmers (and, of course, compliant COBOL compilers) are capable of working in either mode. It is even possible to switch back and forth in the same program. The terms Fixed Format Mode and Free Format Mode are used to refer to these two modes of source code formatting.

The GnuCOBOL compiler (cobc) supports both of these source line format modes, defaulting to Fixed Format Mode lacking any other information.

The compiler can be instructed to operate in either mode in any of the following four ways:

Using a compiler option switch — use the -fixed switch to start in Fixed Format Mode (remember that this is the default) or the -free switch to start in Free Format Mode.
You may use the SOURCEFORMAT AS FIXED and SOURCEFORMAT AS FREE clauses of the >>SET CDF directive (see >>SET) within your source code to switch to Fixed or Free Format Mode, respectively.
You may use the >>FORMAT IS FIXED and FORMAT IS FREE clauses of the >>DEFINE CDF directive (see >>DEFINE) within your source code to switch to Fixed or Free Format Mode, respectively.
You may use the >>SOURCE CDF directive (see >>SOURCE) to switch to Free Format Mode (>>SOURCE FORMAT IS FREE) or Fixed Format Mode (>>SOURCE FORMAT IS FIXED.
Using methods 2-4 above, you may switch back and forth between the two formats at will.

The last three options above are all equivalent; all three are supported by GnuCOBOL so that source code compatibility may be maintained with a wide variety of other COBOL implementations. With all three, if the compiler is currently in Fixed Format Mode, the >> must begin in column 8 or beyond, provided no part of the directive extends past column 72. If the compiler is currently in Free Format Mode, the >> may appear in any column, provided no part of the directive extends past column 255.

Depending upon which source format mode the compiler is in, you will need to follow various rules for the format mode currently in effect. These rules are presented in the upcoming paragraphs.

The following discussion presents the various components of every GnuCOBOL source line record when the compiler is operating in Fixed Format Mode. Remember that this is the default mode for the GnuCOBOL compiler.

1-6
Sequence Number Area

Historically, back in the days when punched-cards were used to submit COBOL program source to a COBOL compiler, this part of a COBOL statement was reserved for a six-digit sequence number. While the contents of this area are ignored by COBOL compilers, it existed so that a program actually punched on 80-character cards could — if the card deck were dropped on the floor — be run through a card sorter machine and restored to its proper sequence. Of course, this isn’t necessary today; if truth be told, it hasn’t been necessary for a long time.

See Marking Changes in Programs, for discussion of a valuable use to which the sequence number area may be put today.

7
Indicator Area

Column 7 serves as an indicator in which one of five possible values will appear — space, D (or d), - (dash), / or *. The meanings of these characters are as follows:

space
No special meaning — this is the normal character that will appear in this area.

D/d
The line contains a valid GnuCOBOL statement that is normally treated as a comment unless the program is being compiled in debugging mode.

*
The line is a comment.

/
The line is a comment that will also force a page eject in the compilation listing. While GnuCOBOL will honour such a line as a comment, it will not form-feed any generated listing.

-
The line is a continuation of the previous line. These are needed only when an alphanumeric literal (quoted character string), reserved word or user-defined word are being split across lines.

8-11
Area A

Language DIVISION, SECTION and paragraph section headers must b egin in Area A, as must the level numbers 01, 77 in data description entries and the FD and SD file and SORT description headers.

12-72
Area B

All other COBOL programming language components are coded in these columns.

73-80
Program Name Area

This is another obsolete area of COBOL statements. This part of every statement also hails back to the day when programs were punched on cards; it was expected that the name of the program (or at least the first 8 characters of it) would be punched here so that — if a dropped COBOL source deck contained more than one program — that handy card sorter machine could be used to first separate the cards by program name and then sort them by sequence number. Today’s COBOL compilers (including GnuCOBOL) simply ignore anything past column 72.

See Marking Changes in Programs, for discussion of a valuable use to which the program name area may be put today.

2.1.17. Program Structure
Complete GnuCOBOL Program Syntax
 [ IDENTIFICATION DIVISION. ]
   ~~~~~~~~~~~~~~~~~~~~~~~
   PROGRAM-ID|FUNCTION-ID.  name-1 [ Program-Options ] .
   ~~~~~~~~~~ ~~~~~~~~~~~
 [ ENVIRONMENT DIVISION. ]
   ~~~~~~~~~~~ ~~~~~~~~
 [ CONFIGURATION SECTION. ]
   ~~~~~~~~~~~~~ ~~~~~~~
 [ SOURCE-COMPUTER.         Compilation-Computer-Specification . ]
   ~~~~~~~~~~~~~~~
 [ OBJECT-COMPUTER.         Execution-Computer-Specification . ]
   ~~~~~~~~~~~~~~~
 [ REPOSITORY.              Function-Specification... . ]
   ~~~~~~~~~~
 [ SPECIAL-NAMES.           Program-Configuration-Specification . ]
   ~~~~~~~~~~~~~
 [ INPUT-OUTPUT SECTION. ]
   ~~~~~~~~~~~~ ~~~~~~~
 [ FILE-CONTROL.            General-File-Description... . ]
   ~~~~~~~~~~~~
 [ I-O-CONTROL.             File-Buffering-Specification... . ]
   ~~~~~~~~~~~
 [ DATA DIVISION. ]
   ~~~~~~~~~~~~~
 [ FILE SECTION.            Detailed-File-Description... . ]
   ~~~~~~~~~~~~
 [ WORKING-STORAGE SECTION. Permanent-Data-Definition... . ]
   ~~~~~~~~~~~~~~~ ~~~~~~~
 [ LOCAL-STORAGE SECTION.   Temporary-Data-Definition... . ]
   ~~~~~~~~~~~~~ ~~~~~~~
 [ LINKAGE SECTION.         Subprogram-Argument-Description... . ]
   ~~~~~~~ ~~~~~~~
 [ REPORT SECTION.          Report-Description... . ]
   ~~~~~~ ~~~~~~~
 [ SCREEN SECTION.          Screen-Layout-Definition... . ]
   ~~~~~~ ~~~~~~~
   PROCEDURE DIVISION [ { USING Subprogram-Argument...      } ]
   ~~~~~~~~~ ~~~~~~~~   { ~~~~~                             }
                        { CHAINING Main-Program-Argument... }
                          ~~~~~~~~
                      [   RETURNING identifier-1 ] .
 [ DECLARATIVES. ]        ~~~~~~~~~
   ~~~~~~~~~~~~
 [ Event-Handler-Routine... . ]
 [ END DECLARATIVES. ]
   ~~~ ~~~~~~~~~~~~
   General-Program-Logic
 [ Nested-Subprogram... ]
 [ END PROGRAM|FUNCTION name-1 ]
   ~~~ ~~~~~~~ ~~~~~~~~
Each program consists of up to four Divisions (major groupings of sections, paragraphs and descriptive or procedural coding that all relate to a common purpose), named Identification, Environment, Data and Procedure.

Not all divisions are needed in every program, but they must be specified in the order shown when they are used.
The following points pertain to the identification division
The IDENTIFICATION DIVISION. header is always optional.
The following points pertain to the environment division:
If both optional sections of this division are coded, they must be coded in the sequence shown.
Each of these sections consists of a series of specific paragraphs (SOURCE-COMPUTER and OBJECT-COMPUTER, for example). Each of these paragraphs serves a specific purpose. If no code is required for the purpose one of the paragraphs serves, the entire paragraph may be omitted.
If none of the paragraphs within one of the sections are coded, the section header itself may be omitted.
The paragraphs within each section may only be coded in that section, but may be coded in any order.
If none of the sections within the environment division are coded, the ENVIRONMENT DIVISION. header itself may be omitted.
The following points pertain to the data division:
The data division consists of six optional sections — when used, those sections must be coded in the order shown in the syntax diagram.
Each of these sections consists of code which serves a specific purpose. If no code is required for the purpose one of those sections serves, the entire section, including its header, may be omitted.
If none of the sections within the data division are coded (a highly unlikely, but theoretically possible circumstance), the DATA DIVISION. header itself may be omitted.
The following points pertain to the procedure division:
As with the other divisions, the procedure division may consist of sections and those sections may — in turn — consist of paragraphs. Unlike the other divisions, however, section and paragraph names are defined by the programmer, and there may not be any defined at all if the programmer so wishes.
Each Event-Handler-Routine will be a separate section devoted to trapping a particular run-time event. If there are no such sections coded, the DECLARATIVES. and END DECLARATIVES. lines may be omitted.
A single file of COBOL source code may contain:
A portion of a program; these files are known as copybooks
A single program. In this case, the END PROGRAM or END FUNCTION statement is optional.
Multiple programs, separated from one another by END PROGRAM or END FUNCTION statements. The final program in such a source code file need not have an END PROGRAM or END FUNCTION statement.
Subprogram ‘B’ may be nested inside program ‘A’ by including program B’s source code at the end of program A’s procedure division without an intervening END PROGRAM A. or END FUNCTION A. statement. For now, that’s all that will be said about nesting. See Independent vs Contained vs Nested Subprograms, for more information.
Regardless of how many programs comprise a single GnuCOBOL source file, only a single output executable program will be generated from that source file when the file is compiled.
2.1.18. Comments
The following information describes how comments may be embedded into GnuCOBOL program source to provide documentation.

Comment Type	Source Mode — Description
Blank Lines	FIXED — Blank lines may be inserted as desired.
FREE — Blank lines may be inserted as desired.

Full-line comments	FIXED — An entire source line will be treated as a comment (and will be ignored by the compiler) by coding an asterisk (‘*’) in column seven (7).
FREE — An entire source line will be treated as a comment (and will be ignored by the compiler) by coding the sequence ‘*>’, starting in any column, as the first non-blank characters on the line.

Full-line comments with form-feed	FIXED — An entire source line will be treated as a comment by coding a slash (‘/’) in column seven (7). Many COBOL compilers will also issue a form-feed in the program listing so that the ‘/’ line is at the top of a new page. The GnuCOBOL compiler does not support this form-feed behaviour.
The GnuCOBOL Interactive Compiler, or GCic, does support this form-feed behaviour when it generates program source listings! See GCic in GnuCOBOL Sample Programs, for the source and cross-reference listing (produced by GCic) of this program — you can see the effect of ‘/’ there.

FREE — There is no Free Source Mode equivalent to ‘/’.

Partial-line comments	FIXED — Any text following the character sequence ‘*>’ on a source line will be treated as a comment. The ‘*’ must appear in column seven (7) or beyond.
FREE — Any text following the character sequence ‘*>’ on a source line will be treated as a comment. The ‘*’ may appear in any column.

Comments that may be treated as code, typically for debugging purposes	FIXED — By coding a ‘D’ in column 7 (upper- or lower-case), an otherwise valid GnuCOBOL source line will be treated as a comment by the compiler.
FREE — By specifying the character sequence ‘>>D’ (upper- or lower-case) as the first non-blank characters on a source line, an otherwise valid GnuCOBOL source line will be treated as a comment by the compiler.

Debugging statements may be compiled either by specifying the -fdebugging-line switch on the GnuCOBOL compiler or by adding the WITH DEBUGGING MODE clause to the SOURCE-COMPUTER paragraph.

2.1.19. Literals
Literals are constant values that will not change during the execution of a program. There are two fundamental types of literals — numeric and alphanumeric.

2.1.19.1. Numeric LiteralsA numeric literal
Integers such as 1, 56, 2192 or -54.
Non-integer fixed point values such as 1.317 or -2.95.
Floating-point values using ‘Enn’ notation such as 9.92E25, representing 9.92 x 1025 (10 raised to the 25th power) or 5.7E-14, representing 5.7 x 10-14 (10 raised to the -14th power). Both the mantissa (the number before the ‘E’) and the exponent (the number after the ‘E’) may be explicitly specified as positive (with a ‘+’), negative (with a ‘-’) or unsigned (and therefore implicitly positive). A floating-point literals value must be within the range -1.7 x 10308 to +1.7 x 10308 with no more than 15 decimal digits of precision.
Hexadecimal numeric literals
Null terminated literals
Raw C string using L"characters".
Binary using B#0 or 1.
Octal using O#0 - 7. (That is the letter ‘O’).
Hexadecimal number using H# or X# ‘0’ - ‘F’.
Boolean Literals (Standard) B" character ".
Boolean Literals (Hexadecimal) BX" hex character ".
National Literals (Standard) N" character " or NC" character ".
National Literals (Hexadecimal) NX" character ".
2.1.19.2. Alphanumeric Literals
An alphanumeric literal

An alphanumeric literal is not valid for use in arithmetic expressions unless it is first converted to its numeric computational equivalent; there are three numeric conversion intrinsic functions built into GnuCOBOL that can perform this conversion — NUMVAL (see NUMVAL), NUMVAL-C (see NUMVAL-C) and NUMVAL-F (see NUMVAL-F).

Alphanumeric literals may take any of the following forms:

A sequence of characters enclosed by a pair of single-quote (‘'’)
A literal formed according to the same rules as for a string literal (above), but prefixed with the letter ‘Z’ (upper- or lower-case) constitutes a zero-delimited string literal. These literals differ from ordinary string literals in that they will be explicitly terminated with a byte of hexadecimal value 00. These Zero-Delimited Alphanumeric Literals
A Hexadecimal Alphanumeric Literal
Alphanumeric literals too long to fit on a single line may be continued to the next line in one of two ways:

If you are using Fixed Format Mode, the alphanumeric literal can be run right up to and including column 72. The literal may then be continued on the next line anywhere after column 11 by coding another quote or apostrophe (whichever was used to begin the literal originally). The continuation line must also have a hyphen (-)
         1         2         3         4         5         6         7   
1234567890123456789012345678901234567890123456789012345678901234567890123

       01  LONG-LITERAL-VALUE-DEMO     PIC X(60) VALUE "This is a long l
      -                                                "ong literal that
      -                                                " must be continu
      -                                                "ed.".
Regardless of whether the compiler is operating in Fixed or Free Format Mode, GnuCOBOL allows alphanumeric literals to be broken up into separate fragments. These fragments have their own beginning and ending quote/apostrophe characters and are “glued together” at compilation time using ‘&’
         1         2         3         4         5         6         7   
1234567890123456789012345678901234567890123456789012345678901234567890123

      01  LONG-LITERAL-VALUE-DEMO      PIC X(60) VALUE "This is a" &
                                        " long literal that must " &
                                                    "be continued.".
If your program is using Free Format Mode, there’s less need to continue long alphanumeric literals because statements may be as long as 255 characters.

Numeric literals may be split across lines just as alphanumeric literals are, using either of the above techniques and both reserved and user-defined words can be split across lines too (using the first technique). The continuation of numeric literals and user-defined/reserved words is provided merely to provide compatibility with older COBOL versions and programs, but should not be used with new programs — it just makes for ugly-looking programs.

2.1.19.3. Figurative Constants
Figurative constants are reserved words that may be used as literals anywhere the figurative constants value could be interpreted as an arbitrarily long sequence of the characters in question. When a specific length is required, such as would be the case with an argument to a subprogram, a figurative constant may not be used. Thus, the following are valid uses of figurative constants:

05 FILLER                PIC 9(10) VALUE ZEROS.
   ...
MOVE SPACES TO Employee-Name
But this is not:

CALL "SUBPGM" USING SPACES
The following are the GnuCOBOL figurative constants and their respective equivalent values.

ZERO
This figurative constant has a value of numeric 0 (zero). ZEROS and ZEROES are both synonyms of ZERO.

SPACE
This figurative constant has a value of one or more space characters. SPACES is a synonym of SPACE.

QUOTE
This figurative constant has a value of one or more double-quote characters ("). QUOTES is a synonym of QUOTE.

LOW-VALUE
This figurative constant has a value of one or more of whatever character occupies the lowest position in the program’s collating sequence as defined in the OBJECT-COMPUTER (see OBJECT-COMPUTER) paragraph or — if no such specification was made — in whatever default character set the program is using (typically, this is the ASCII character set). LOW-VALUES is a synonym of LOW-VALUE.

When the character set in use is ASCII with no collating sequence modifications, the LOW-VALUES figurative constant value is the ASCII NUL character. Because character sets can be redefined, however, you should not rely on this fact. Use the NULL figurative constant instead.

HIGH-VALUE
This figurative constant has a value of one or more of whatever character occupies the highest position in the program’s collating sequence as defined in the OBJECT-COMPUTER paragraph or — if no such specification was made — in whatever default character set the program is using (typically, this is the ASCII character set). HIGH-VALUES is a synonym of HIGH-VALUE.

NULL
A character comprised entirely of zero-bits (regardless of the programs collating sequence).

Programmers may create their own figurative constants via the SYMBOLIC CHARACTERS (see Symbolic-Characters-Clause) clause of the SPECIAL-NAMES (see SPECIAL-NAMES) paragraph.

2.1.20. Punctuation
A comma (‘,’)

The use of comma characters can cause confusion to a COBOL compiler if the DECIMAL POINT IS COMMA clause is used in the SPECIAL-NAMES (see SPECIAL-NAMES) paragraph, as might be the case in Europe. The following statement, which calls a subroutine passing it two arguments (the numeric constants 1 and 2):

CALL "SUBROUTINE" USING 1,2
Would — with DECIMAL POINT IS COMMA in effect — actually be interpreted as a subroutine call with 1 argument (the non-integer numeric literal whose value is 1 and 2 tenths). For this reason, it is best to always follow a comma with a space.

The period character (‘.’)

The rules for where and when periods are needed in the procedure division are somewhat complicated. See Use of Periods, for the details.

2.1.21. Interfacing to Other Environments
Through the CALL statement, COBOL programs may invoke other COBOL programs serving as subprograms. This is quite similar to cross-program linkage capabilities provided by other languages. In GnuCOBOL’s case, the CALL facility is powerful enough to be tailored to the point where a GnuCOBOL program can communicate with operating system, database management and run-time library APIs, even if they weren’t written in COBOL themselves. See GnuCOBOL Main Programs CALLing C Subprograms, for an example of how a GnuCOBOL program could invoke a C-language subprogram, passing information back and forth between the two.

The fact that GnuCOBOL supports a full-featured two-way interface with C-language programs means that — even if you cannot access a library API directly — you could always do so via a small C “wrapper” program that is CALLed by a GnuCOBOL program.